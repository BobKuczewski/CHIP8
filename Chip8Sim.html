<!DOCTYPE html>
<html>

<head>
<title>CHIP-8 Development Environment</title>
<meta charset="utf-8"/>
</head>

<style>
table.reg,table.mem {
  font-size: 110%;
  border: 1px solid black;
  border-collapse: collapse;
  /* border-spacing: 0px; */
}
tr.reg,tr.mem {
  font-size: 110%;
  background-color: #000000;
  border: none;
  padding: 0px;
  margin: 0px;
}
td.reg,td.mem {
  font-size: 70%;
  background-color: #ffffff;
  border: 1px solid black;
  padding: 0px;
  padding-left: 4px;
  padding-right: 4px;
  margin: 0px;
  text-align: center;
  /*outline-width: 0px;*/
}
input.reg,input.mem {
  font-size: 110%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: right;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 12px;
  /*outline-width: 0px;*/
}
input.regleft {
  font-size: 110%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: left;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 12px;
  /*outline-width: 0px;*/
}
table.ex, th.ex, tr.ex, td.ex {
  border: 2px solid black;
	font-family: monospace;
	font-weight: bold;
	font-size: 100%;
	padding-top: 3px;
	padding-left: 5px;
	padding-right: 5px;
	padding-bottom: 1px;
  border-collapse: collapse;
}
th.ex {
	font-size: 120%;
}
</style>

<script>

mem = [];
mem_top = 0x0200; // Address of memory shown at top of the memory list
V = [];
PC = 0x0200; // Program Counter typically starts at 0x0200
SP = 0x0001; // Set stack pointer at 1 since it is incremented before use
I = 0x0000;  // Index register
N = 0;       // Number of instructions since reset
CT = 1;      // Clock Time (time per clock tick
ST = 1000;   // Steps per clock tick

num_rows = 32;
num_cols = 64;
screen = [];
fg_color = "#AAAAff";
bg_color = "#000044";
font_addr = 0x0FA0;  // This could be anywhere but stack or program memory

function replaceAll ( s, t, r ) {
	new_s = (s + " ").trim();
	do {
		last_s = (new_s + " ").trim();
	  new_s = last_s.replace(t,r);
	} while ( ! (new_s === last_s) );
	return ( new_s );
}

function pad0 (val, n) {
  v = val;
  while (v.length < n) {
    v = "0" + v;
  }
  return ( v );
}

function hex (val) {
	return ( val.toString(16).toUpperCase() );
}

function clear_screen() {
  // Clear the display memory
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      screen[r][c] = 0;
    }
  }
	draw_screen();
}

function draw_screen() {
  da = document.getElementById ("drawing_area");
  ctxt = da.getContext('2d');
  ctxt.fillStyle = bg_color;
  ctxt.fillRect(0, 0, da.width, da.height);
  ctxt.fillStyle = fg_color;
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      if (screen[r][c] != 0) {
	      ctxt.fillRect(5*c, 5*r, 5, 5);
	    }
    }
  }
}

function update_display() {
  update_variables();
  // Show the Memory starting with mem_top (even addresses)
  base_addr = 2 * Math.floor(mem_top/2);
  for (i=0; i<16; i++) {
    i_text = i.toString(16).toUpperCase().trim();
    addr = base_addr + (2*i);
    mem_val = (mem[addr] << 8) + mem[addr+1];
    document.getElementById("A"+i_text).innerHTML = pad0 ( addr.toString(16).toUpperCase(), 4 );
    document.getElementById("M"+i_text).value = pad0 ( mem_val.toString(16).toUpperCase(), 4 );
  }
  // Show the register values
  for (i=0; i<16; i++) {
    i_text = i.toString(16).toUpperCase().trim();
    v = "V" + i_text;
    document.getElementById(v).value = pad0 ( V[i].toString(16).toUpperCase(), 2 );
  }
  document.getElementById("PC").value = pad0 ( PC.toString(16).toUpperCase(), 4 );
  document.getElementById("SP").value = pad0 ( SP.toString(16).toUpperCase(), 4 );
  opcode = pad0(mem[PC].toString(16).toUpperCase(),2) + pad0(mem[PC+1].toString(16).toUpperCase(),2)
  document.getElementById("PCINST").value = disassemble_line( opcode.trim() );
  document.getElementById("[I]").value = pad0 ( I.toString(16).toUpperCase(), 4 );
  document.getElementById("N").value = N.toString();
  document.getElementById("ST").value = ST.toString();
  document.getElementById("CT").value = CT.toString();
}

function init_machine() {
  // Initialize the memory
  mem = [];
  for (i=0; i<0x10000; i++) {
    mem.push(0xff);
  }
  // Load the Font data (80 bytes total)
  // Each entry is 4 columns x 5 rows
  // Sprites are 8 columns wide but
  // these only use the first 4 bits
  font_data = [
		[0xF0, 0x90, 0x90, 0x90, 0xF0], // 0
		[0x20, 0x60, 0x20, 0x20, 0x70], // 1
		[0xF0, 0x10, 0xF0, 0x80, 0xF0], // 2
		[0xF0, 0x10, 0xF0, 0x10, 0xF0], // 3
		[0x90, 0x90, 0xF0, 0x10, 0x10], // 4
		[0xF0, 0x80, 0xF0, 0x10, 0xF0], // 5
		[0xF0, 0x80, 0xF0, 0x90, 0xF0], // 6
		[0xF0, 0x10, 0x20, 0x40, 0x40], // 7
		[0xF0, 0x90, 0xF0, 0x90, 0xF0], // 8
		[0xF0, 0x90, 0xF0, 0x10, 0xF0], // 9
		[0xF0, 0x90, 0xF0, 0x90, 0x90], // A
		[0xE0, 0x90, 0xE0, 0x90, 0xE0], // B
		[0xF0, 0x80, 0x80, 0x80, 0xF0], // C
		[0xE0, 0x90, 0x90, 0x90, 0xE0], // D
		[0xF0, 0x80, 0xF0, 0x80, 0xF0], // E
		[0xF0, 0x80, 0xF0, 0x80, 0x80]  // F
	];
	i = font_addr;
	// console.log ( "Loading Font Data" );
	for (r=0; r<font_data.length; r++) {
		for (c=0; c<font_data[r].length; c++) {
			mem[i] = font_data[r][c];
			i+=1;
		}
	}
  // Initialize the "V" registers
  V = [];
  for (i=0; i<16; i++) {
    V.push(0);
  }
  // Initialize the display memory
  screen = [];
  for (r=0; r<num_rows; r++) {
    row = [];
    for (c=0; c<num_cols; c++) {
      row.push(0);
    }
    screen.push(row)
  }
  update_display();
  draw_screen();
}

function load_menus() {
  example_menu = document.getElementById("example_select");
  ex = document.getElementsByClassName("exsrc");
  for (i=0; i<ex.length; i++) {
    opt = document.createElement ( "option" );
    opt.value = ex[i].id;
    opt.innerHTML = ex[i].id;
    example_menu.appendChild ( opt );
    // console.log ( "Example: " + ex[i].id );
  }
}

function load_example() {
  document.getElementById ( "source" ).value = document.getElementById("Draw XOR box").innerHTML;
}

function onload() {
  load_menus();
  load_example();
  init_machine();
  clear_screen();
}

function changed_format() {
  // fmt = document.getElementById ("format_to").value;
  // console.log ("Format changed to " + fmt);
}

function get_b_comma_vx ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1);
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_b ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2);
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_vy ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_vy (" + s + ") = " + result );
  return ( result );
}

function assemble_text ( srctxt ) {
  // console.log ("Assemble code");
  // srctxt = document.getElementById ( "source" ).value;
  // console.log ( "Text = " + srctxt );

  // Initialize the binary text outpu
  bintxt = "";

  // Normalize line endings and remove empty lines
	text = replaceAll( srctxt, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	// console.log ( text );
	// Convert all white space to spaces
	// text = text.replace(/\s+/g,' ');
  // Remove all double spaces
	while (text.indexOf("  ") >= 0) {
		text = replaceAll(text, "  ", " ");
	}
	// console.log ( text );
	// Split the text into an array of lines
  lines = text.split("\n");
	// console.log ( "lines=" + lines );

  // Remove all comments and empty lines
  new_lines = [];
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
	  if (line.indexOf(";") >= 0) {
			// Remove the comment
			line = line.substr(0,line.indexOf(";")).trim();
	  }
	  if (line.trim().length > 0) {
			new_lines.push ( line.trim() );
	  }
	}
	lines = new_lines;

	// Remove any and all last lines containing empty labels
	while ( lines[lines.length-1].indexOf(":") == (lines[lines.length-1].length-1) ) {
	  // Copy all but the last line
	  new_lines = [];
		for (l=0; l<(lines.length-1); l++) {
		  new_lines[l] = lines[l];
		}
		lines = new_lines;
	}

	// Merge empty labels with subsequent lines
	new_lines = [];
	l = 0;
	while (l<lines.length) {
		line = lines[l];
		if (line.indexOf(":") == (line.length-1)) {
			// This is an empty label so join it with the next line
			l = l + 1;
			new_lines.push ( line + " " + lines[l] );
		} else {
			// Just push this line by itself
			new_lines.push ( line );
		}
		l = l + 1;
	}
	lines = new_lines;

  // Compute the label addresses
  label_dict = {};
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
	  if (line.indexOf(":") >= 0) {
	    // Store the label and its location
	    label = line.substr(0,line.indexOf(":"));
	    label_dict[label] = ((2*l)+0x200).toString(16);
	    while (label_dict[label].length < 3) {
	      label_dict[label] = '0' + label_dict[label];
	    }
	    // Remove the label from the line of code for assembly
	    lines[l] = lines[l].substr(line.indexOf(":")+1).trim();
	  }
	}
	keys = Object.keys(label_dict);
	// console.log ( "labels = " + keys );
	for (l=0; l<lines.length; l++) {
	  for (ki=0; ki<keys.length; ki++) {
	    // console.log ( "Searching for " + keys[ki] );
      lines[l] = replaceAll( lines[l].toUpperCase(), keys[ki], label_dict[keys[ki]]);
	  }
	}

	// Process the lines one by one
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
		// line = lines[l].replace(/\s+/g,''); // Remove all white space
	  if (line.indexOf(";") >= 0) {
			// Remove the comment
			line = line.substr(0,line.indexOf(";")).trim();
	  }
	  if (line.length > 0) {
		  if (line.indexOf(":") >= 0) {
				// Throw away the labels for now
				line = line.substr(line.indexOf(":")+1).trim();
		  }
		  if (line.slice(0,5) == "DATA ") {
				bintxt += line.slice(5).trim() + "\n";
		  } else if (line.slice(0,4) == "SYS ") {
				bintxt += "0" + line.slice(4).trim() + "\n";
		  } else if (line.slice(0,3) == "CLS") {
				bintxt += "00E0\n";
		  } else if (line.slice(0,3) == "RET") {
				bintxt += "00EE\n";
		  } else if (line.slice(0,3) == "JP ") {
				// JP can take the following forms:
				//   JP nnn    -->  1nnn
				//   JP V0,nnn -->  Bnnn
				if (line.indexOf(",") >= 0) {
					bintxt += "B" + line.slice(line.indexOf(",")+1).trim() + "\n";
			  } else {
					bintxt += "1" + line.slice(2).trim() + "\n";
			  }
		  } else if (line.slice(0,5) == "CALL ") {
				// CALL takes the following form:
				//   CALL nnn
				bintxt += "2" + line.slice(5).trim() + "\n";
		  } else if (line.slice(0,3) == "SE ") {
				// SE (Skip when Equal) can take the following forms:
				//   SE Vx,byte -> 3xbb
				//   SE Vx,Vy   -> 5xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SE Vx,byte -> 3xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					bintxt += "3" + vb[0] + vb[1] + "\n";
				} else {
					// SE Vx,Vy   -> 5xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					bintxt += "5" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,4) == "SNE ") {
				// SNE (Skip when Not Equal) can take the following forms:
				//   SNE Vx,byte -> 4xbb
				//   SNE Vx,Vy   -> 9xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SNE Vx,byte -> 4xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					bintxt += "4" + vb[0] + vb[1] + "\n";
				} else {
					// SNE Vx,Vy   -> 9xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					bintxt += "9" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,3) == "LD ") {
				// LD (Load) can take the following forms:
				//   LD Vx,byte -> 6xbb
				//   LD Vx,Vy   -> 8xy0
				//   LD I,nnn   -> Annn
				//   LD Vx,DT   -> Fx07
				//   LD Vx,K    -> Fx0A
				//   LD DT,Vx   -> Fx15
				//   LD ST,Vx   -> Fx18
				//   LD F,Vx    -> Fx29
				//   LD B,Vx    -> Fx33
				//   LD [I],Vx  -> Fx55
				//   LD Vx,[I]  -> Fx65
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				// Handle the easy ones first
				if (pars[0] == "I") {
				  // LD I,nnn   -> Annn
					bintxt += "A" + pars[1].trim() + "\n";
				} else if (pars[0] == "DT") {
				  // LD DT,Vx   -> Fx15
					bintxt += "F" + pars[1].slice(1).trim() + "15\n";
				} else if (pars[0] == "ST") {
					// LD ST,Vx   -> Fx18
					bintxt += "F" + pars[1].slice(1).trim() + "18\n";
				} else if (pars[0] == "F") {
					// LD F,Vx    -> Fx29
					bintxt += "F" + pars[1].slice(1).trim() + "29\n";
				} else if (pars[0] == "B") {
					// LD B,Vx    -> Fx33
					bintxt += "F" + pars[1].slice(1).trim() + "33\n";
				} else if (pars[0] == "[I]") {
					// LD [I],Vx  -> Fx55
					bintxt += "F" + pars[1].slice(1).trim() + "55\n";
				} else if (pars[1] == "DT") {
				  // LD Vx,DT   -> Fx07
					bintxt += "F" + pars[0].slice(1).trim() + "07\n";
				} else if (pars[1] == "K") {
				  // LD Vx,K    -> Fx0A
				} else if (pars[1] == "[I]") {
					// LD Vx,[I]  -> Fx65
					bintxt += "F" + pars[0].slice(1).trim() + "65\n";
				} else {
				  if (line.split(",")[1].indexOf("V") < 0) {
						// LD Vx,byte -> 6xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  bintxt += "6" + vb[0] + vb[1] + "\n";
				  } else {
						// LD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
						bintxt += "8" + vv[0] + vv[1] + "0" + "\n";
					}
				}
		  } else if (line.slice(0,4) == "ADD ") {
				// ADD can take the following forms:
				//   ADD Vx,byte -> 7xbb
				//   ADD Vx,Vy   -> 8xy4
				//   ADD I,Vx    -> Fx1E
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				if (pars[0] == "I") {
				  // ADD I,Vx    -> Fx1E
					bintxt += "F" + pars[1].slice(1).trim() + "1E\n";
			  } else {
				  if (pars[1].indexOf("V") < 0) {
						// ADD Vx,byte -> 7xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  bintxt += "7" + vb[0] + vb[1] + "\n";
				  } else {
				  	// ADD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
					  bintxt += "8" + vv[0] + vv[1] + "4" + "\n";
					}
			  }
		  } else if (line.slice(0,3) == "OR ") {
				vv = get_vx_comma_vy ( line.slice(2).trim() );
			  bintxt += "8" + vv[0] + vv[1] + "1" + "\n";
		  } else if (line.slice(0,4) == "AND ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  bintxt += "8" + vv[0] + vv[1] + "2" + "\n";
		  } else if (line.slice(0,4) == "XOR ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  bintxt += "8" + vv[0] + vv[1] + "3" + "\n";
		  } else if (line.slice(0,4) == "SUB ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  bintxt += "8" + vv[0] + vv[1] + "5" + "\n";
		  } else if (line.slice(0,4) == "SHR ") {
				if (line.indexOf(",") >= 0) {
				  // SHR Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHR Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  bintxt += "8" + vv[0] + vv[1] + "6" + "\n";
		  } else if (line.slice(0,5) == "SUBN ") {
				vv = get_vx_comma_vy ( line.slice(4).trim() );
			  bintxt += "8" + vv[0] + vv[1] + "7" + "\n";
		  } else if (line.slice(0,4) == "SHL ") {
				if (line.indexOf(",") >= 0) {
				  // SHL Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHL Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  bintxt += "8" + vv[0] + vv[1] + "E" + "\n";
		  } else if (line.slice(0,4) == "RND ") {
				vb = get_vx_comma_b ( line.slice(3) );
			  bintxt += "C" + vb[0] + vb[1] + "\n";
		  } else if (line.slice(0,4) == "DRW ") {
		  	pars = line.slice(3).split(",");
		  	pars[0] = pars[0].trim();
		  	pars[1] = pars[1].trim();
		  	pars[2] = pars[2].trim();
			  bintxt += "D" + pars[0][1] + pars[1][1] + pars[2][0] + "\n";
		  } else if (line.slice(0,4) == "SKP ") {
		  	vx = line.slice(3).trim();
			  bintxt += "E" + vx[1] + "9E" + "\n";
		  } else if (line.slice(0,5) == "SKNP ") {
		  	vx = line.slice(4).trim();
			  bintxt += "E" + vx[1] + "A1" + "\n";
		  } else {
				bintxt += "[??]" + line + "\n";
		  }
		}
  }
  return ( bintxt );
}

function assemble() {
  // console.log ("Assemble source code window to machine code window");
  srctxt = document.getElementById ( "source" ).value;
  document.getElementById ( "machine" ).value = assemble_text ( srctxt );
}

function get_machine_lines ( text_in ) {
  // Normalize line endings and remove empty lines
	text = replaceAll( text_in, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	// Convert to upper case
	text = "" + text.toUpperCase();
	// Remove all line endings
	while (text.indexOf("\n") >= 0) {
		text = replaceAll(text, "\n", "");
	}
	// Remove all spaces
	while (text.indexOf(" ") >= 0) {
		text = replaceAll(text, " ", "");
	}
	// Split by 4 digits per instruction
  lines = [];
  while (text.length > 0) {
		lines.push ( text.slice(0,4) );
		text = text.slice(4)
  }
  return ( lines );
}

function disassemble_line ( line ) {

  result = "";

	// #### : 00E0 00EE
  if (line == "00E0") {
	  result += "CLS";
	} else if (line == "00EE") {
	  result += "RET";

	// #nnn : 0 1 2 A B
	} else if (line[0] == "0") {
	  result += "SYS " + line.slice(1);
	} else if (line[0] == "1") {
	  // result += "JP L" + line.slice(1);
	  result += "JP " + line.slice(1);
	} else if (line[0] == "2") {
	  // result += "CALL L" + line.slice(1);
	  result += "CALL " + line.slice(1);
	} else if (line[0] == "A") {
	  result += "LD I," + line.slice(1);
	} else if (line[0] == "B") {
	  result += "JP V0," + line.slice(1);

	// #nkk or #xkk : 3 4 6 7 C
	} else if (line[0] == "3") {
	  result += "SE V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "4") {
	  result += "SNE V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "6") {
	  result += "LD V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "7") {
	  result += "ADD V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "C") {
	  result += "RND V" + line[1] + "," + line.slice(2);

	// #xy# : 5, 8, 9, D
	} else if (line[0] == "5") {
	  if (line[3] == "0") {
		  result += "SE V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "8") {
	  if (line[3] == "0") {
		  result += "LD V" + line[1] + ",V" + line[2];
		} else if (line[3] == "1") {
		  result += "OR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "2") {
		  result += "AND V" + line[1] + ",V" + line[2];
		} else if (line[3] == "3") {
		  result += "XOR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "4") {
		  result += "ADD V" + line[1] + ",V" + line[2];
		} else if (line[3] == "5") {
		  result += "SUB V" + line[1] + ",V" + line[2];
		} else if (line[3] == "6") {
		  result += "SHR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "7") {
		  result += "SUBN V" + line[1] + ",V" + line[2];
		} else if (line[3] == "E") {
		  result += "SHL V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "9") {
	  if (line[3] == "0") {
		  result += "SNE V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "D") {
	  result += "DRW V" + line[1] + ",V" + line[2] + "," + line[3];

	// #x## : E, F
	} else if (line[0] == "E") {
	  if (line.slice(2) == "9E") {
		  result += "SKP V" + line[1];
	  } else if (line.slice(2) == "A1") {
		  result += "SKNP V" + line[1];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "F") {
	  if (line.slice(2) == "07") {
		  result += "LD V" + line[1] + ",DT";
	  } else if (line.slice(2) == "0A") {
		  result += "LD V" + line[1] + ",K";
	  } else if (line.slice(2) == "15") {
		  result += "LD DT,V" + line[1];
	  } else if (line.slice(2) == "18") {
		  result += "LD ST,V" + line[1];
	  } else if (line.slice(2) == "1E") {
		  result += "ADD I,V" + line[1];
	  } else if (line.slice(2) == "29") {
		  result += "LD F,V" + line[1];
	  } else if (line.slice(2) == "33") {
		  result += "LD B,V" + line[1];
	  } else if (line.slice(2) == "55") {
		  result += "LD [I],V" + line[1];
	  } else if (line.slice(2) == "65") {
		  result += "LD V" + line[1] + ",[I]";
		} else {
		  result += "DATA " + line;
		}

	// Unknown
	} else {
	  result += "DATA " + line;
	}

  return ( result );
}


function disassemble() {
  // console.log ("Disassemble code");
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines
	lines = get_machine_lines ( bintxt );
  // console.log ( "Text = " + bintxt );
  opts = document.getElementById ( "disassem_opts" ).value;
  // console.log ( "Disassemble with options: " + opts );
  // Clear the source window
  document.getElementById ( "source" ).value = "";
	// Process the lines one by one
	for (l=0; l<lines.length; l++) {
		if (opts.indexOf("L") >= 0) {
		  // document.getElementById ( "source" ).value += "L"+((l*2)+0x200).toString(16).toUpperCase() + ": ";
		  document.getElementById ( "source" ).value += ((l*2)+0x200).toString(16).toUpperCase() + ": ";
		}
		if (opts.indexOf("H") >= 0) {
		  document.getElementById ( "source" ).value += lines[l] + "  ";
		}
    document.getElementById ( "source" ).value += disassemble_line ( lines[l] ) + "\n";
  }
}

saved_text = "";
function save() {
  saved_text = document.getElementById ( "source" ).value;
}

function restore() {
  document.getElementById ( "source" ).value = saved_text;
}

function load() {
  // Load from the machine code text area into mem
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines of instructions
	lines = get_machine_lines ( bintxt );
  addr = 0x0200;
	for (i=0; i<lines.length; i++) {
	  mem[addr++] = parseInt ( lines[i].slice(0,2), 16 );
	  mem[addr++] = parseInt ( lines[i].slice(2,4), 16 );
	}
	update_display();
}

function reset() {
  PC = 0x0200;
  SP = 0x0001;
  I  = 0x0000;
  N = 0;
	for (i=0; i<16; i++) {
	  V[i] = 0;
	}
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      screen[r][c] = 0;
    }
  }
	draw_screen();
	update_display();
}

function step1() {
  // Could not use the name "step" for some reason?
  instruction = (mem[PC] << 8) + mem[PC+1];
  // console.log ( "Execute " + pad0(instruction.toString(16).toUpperCase(),4) );
  if (instruction == 0x00E0) { // CLS
    // console.log ( "CLS" );
    clear_screen();
	  PC = PC + 2;
  } else if (instruction == 0x00EE) { // RET
    // console.log ( "RET" );
    // Cowgod: The interpreter sets the program counter to the address
    //         at the top of the stack, then subtracts 1 from the stack pointer.
    PC = (mem[SP-1] << 8) | mem[SP];
    PC = PC + 2;
    SP = SP - 2;
  } else if ( (instruction & 0xF000) == 0x0000) {  // SYS NNN
    // console.log ( "SYS" );
    window.alert ( "The SYS instruction is at " + hex(PC) + " is not implemented" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x1000) {  // JP NNN
    // console.log ( "JP" );
    PC = instruction & 0xFFF;
  } else if ( (instruction & 0xF000) == 0x2000) { // CALL NNN
    // console.log ( "CALL" );
    // Cowgod: The interpreter increments the stack pointer,
    //         then puts the current PC on the top of the stack.
		//         The PC is then set to nnn.

    // Push the high byte onto the stack
    SP = SP + 1;
    mem[SP] = (PC >> 8) & 0x00FF;
    // Push the low byte onto the stack
    SP = SP + 1;
    mem[SP] = PC & 0x00FF;
    // Jump to the new location
    PC = instruction & 0xFFF;
  } else if ( (instruction & 0xF000) == 0x3000) { // SE Vx,byte
    // console.log ( "SE Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    if ( V[(instruction&0x0F00)>>8] == (instruction&0x00FF) ) {
		  PC = PC + 4;
		} else {
		  PC = PC + 2;
		}
  } else if ( (instruction & 0xF000) == 0x4000) { // SNE Vx,byte
    // console.log ( "SNE - Skip if Not Equal immediate" );
    if ( V[(instruction&0x0F00)>>8] != (instruction&0x00FF) ) {
		  PC = PC + 4;
		} else {
		  PC = PC + 2;
		}
  } else if ( (instruction & 0xF000) == 0x5000) { // SE Vx,Vy
    // console.log ( "SE - Skip if Equal Reg" );
    if ( V[(instruction&0x0F00)>>8] == V[(instruction&0x00F0)>>4]  ) {
		  PC = PC + 4;
		} else {
		  PC = PC + 2;
		}
  } else if ( (instruction & 0xF000) == 0x6000) { // LD Vx,byte
    // console.log ( "LD immediate with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = instruction&0x00FF;
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x7000) { // ADD Vx,byte
    // console.log ( "ADD immediate === Add Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    x = (instruction&0x0F00)>>8;
    V[x] = V[x] + (instruction&0x00FF);
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8000) { // LD Vx,Vy
    // console.log ( "LD Vx,Vy" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8001) { // OR Vx,Vy
    // console.log ( "OR Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] | V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8002) { // AND Vx,Vy
    // console.log ( "AND Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] & V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8003) { // XOR Vx,Vy
    // console.log ( "XOR Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] ^ V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8004) { // ADD Vx,Vy
    // console.log ( "ADD Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] + V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8005) { // SUB Vx,Vy: Vx = Vx - Vy
    // console.log ( "SUB Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] - V[(instruction&0x00F0)>>4];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8006) { // SHR Vx,Vy: Vx = Vy >> 1
    // console.log ( "SHR" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x00F0)>>4] >> 1;
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8007) { // SUBN Vx,Vy: Vx = Vy - Vx
    // console.log ( "SUBN" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x00F0)>>4] - V[(instruction&0x0F00)>>8];
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x800E) { // SHL Vx,Vy
    // console.log ( "SHL" );
    V[(instruction&0x0F00)>>8] = (V[(instruction&0x00F0)>>4] << 1) & 0xff;
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x9000) { // SNE Vx,Vy
    // console.log ( "SNE - Skip if Not Equal Reg" );
    if ( V[(instruction&0x0F00)>>8] != V[(instruction&0x00F0)>>4] ) {
		  PC = PC + 4;
		} else {
		  PC = PC + 2;
		}
  } else if ( (instruction & 0xF000) == 0xA000) { // I = NNN
    // console.log ( "LD I, addr" );
    I = instruction & 0xFFF;
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xB000) { // JP V0,NNN
    // console.log ( "JP V0, addr" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xC000) { // RND Vx,byte
		// console.log ( "RND Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = Math.floor(Math.random() * 256) & (instruction&0x00FF);
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xD000) { // DRW Vx,Vy,n
    // Draw a sprite at Vx,Vy of size nx8 from bytes at [I]
    vx = ( instruction & 0x0F00 ) >> 8;
    vy = ( instruction & 0x00F0 ) >> 4;
    n = instruction & 0x000F;
    for (pixrow=0; pixrow<n; pixrow++) {
      for (c=0; c<8; c++) {
			// Plain drawing (draw 1 in each location)
			//if ( mem[I+pixrow] & (0x80 >> c) ) {
			//  screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] = 1;
			//}
			// XOR drawing (perform XOR of each pix with memory)
        if ( mem[I+pixrow] & (0x80 >> c) ) {
          bit = 1;
        } else {
          bit = 0;
        }
        pix = ( bit ^ screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] );
		    screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] = pix;
			}
    }
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xE09E) { // SKP Vx (Skip Key Vx is Pressed
    // console.log ( "SKP Vx" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xE0A1) { // SKNP Vx (Skip Key Vx is Not Pressed
    // console.log ( "SKNP Vx" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF007) { // LD Vx, DT
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF00A) { // LD Vx, K
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF015) { // LD DT, Vx
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF018) { // LD ST, Vx
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF01E) { // ADD I, Vx
    // console.log ( "LD Vx,DT" );
    I = I + V[(instruction&0x0F00)>>8];
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF029) { // LD F, Vx
    // It's not clear if the "Vx" should represent:
    //   (a) the 4-bit number corresponding to the digit to be drawn
    digit = (instruction&0x0F00)>>8;
    //   (b) the 4-bit register number holding the number of the digit
    // digit = V[(instruction&0x0F00)>>8];
    // console.log ( "LD Vx,DT" );
    I = font_addr + (5 * digit); // There are 5 rows per digit
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF033) { // LD B, Vx
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF055) { // LD [I], Vx
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF065) { // LD Vx, [I]
    // console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else {
    // console.log ( "UNKNOWN INSTRUCTION: " + pad0(instruction.toString(16).toUpperCase(),4) );
	  PC = PC + 2;
  }
  N = N + 1;
	update_display();
	draw_screen();
}

function run1() {
  step1();
}

function run() {
  // ST = parseInt ( document.getElementById("ST").value );
  // CT = parseInt ( document.getElementById("CT").value );
	for (stepnum=0; stepnum<ST; stepnum++) {
		step1();
	}
}

function stop() {
}

function update_variables() {
  ST = parseInt ( document.getElementById("ST").value );
  CT = parseInt ( document.getElementById("CT").value );
}

function on_doc_change() {
  // console.log ( "on_doc_change called" );
	let selector = document.getElementById("show_help");
	let setting = selector[selector.selectedIndex].value;
	let n = selector.options.length;
	for (let i=0; i<n; i++) {
	  let ith_id = selector.options[i].value;
	  if (ith_id == setting) {
	    document.getElementById(ith_id).hidden = false;
	  } else {
	    document.getElementById(ith_id).hidden = true;
	  }
	}
}


function on_example_change() {
	let selector = document.getElementById("example_select");
	let setting = selector[selector.selectedIndex].value;
  document.getElementById ( "source" ).value = document.getElementById(setting).innerHTML;
}

</script>

<body bgcolor="lightblue" onload="onload()">
<center>

<span id="title"><b>CHIP-8 Development Environment</b></span>
<p/>
<center>
<table>
	<tr>
	  <!--
		<td>
			<select id="assem_opts" onchange="changed_format()">
			<option value="H" selected>Plain Hex</option>
			<option value="I">Intel Hex</option>
			</select>
		</td>
		-->
		<td>
			<input type="button" name="assem" value="Assemble" onclick="assemble();"></input>
		</td>
		<td>
			<input type="button" name="save" value="Save" onclick="save();"></input>
		</td>
		<td>
			<input type="button" name="restore" value="Restore" onclick="restore();"></input>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp; 
		  <input type="button" name="disassem" value="Disassemble as" onclick="disassemble();"></input>
		</td>
		<td>
			<select id="disassem_opts" onchange="changed_format()">
			<option value="S">Src</option>
			<option value="LS" selected>L+S</option> -->
			<option value="HS">H+S</option> -->
			<option value="LHS">LHS</option> -->
			</select>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp;
			<input type="button" name="load"  value="Load"  onclick="load();"></input>
			<input type="button" name="reset"  value="Reset"  onclick="reset();"></input>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp;
			<input type="button" name="run1" value="Step" onclick="run1();"></input>
			<input type="button" name="run"  value="Run"  onclick="run();"></input>
			<input type="button" name="stop" value="Stop" onclick="stop();"></input>
			&nbsp; &nbsp;
			<input type="button" name="stop" value="↻" onclick="assemble(); load(); reset(); run();""></input>
		</td>
	</tr>
</table>
<center>
<table width="100%" style="padding:10px; border-spacing:2px; border:4px solid black; background-color:#dddddd; text-align:left; font-family: Arial, Helvetica, sans-serif; font-size: 14px;" >
  <colgroup>
		<col>
		<col>
  </colgroup>
  <thead>
		<tr>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Source Code</th>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Machine Code</th>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Chip-8 Virtual Machine</th>
		</tr>
  </thead>
	<tbody>
  	<tr>
		  <td valign="top">
				<center>
				<textarea id="source" rows="27" cols="64"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false"></textarea>
				</center>
			</td>

		  <td valign="top">
				<center>

				<textarea id="machine" rows="27" cols="5"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false"></textarea>
				</center>
			</td>

		  <td valign="top"> <!-- Start of VIRTUAL MACHINE -->
		    <center>
		    <table>
		    <tr><td>
				<center>
					<!--div id="tdiv" style="resize: both; overflow: auto;"--> 
					<div id="tdiv">
					<center>
					<canvas id="drawing_area" width="320" height="160"
						style="margin:2px; padding:2px; border:2px solid #cccccc; resize: both; overflow: auto;"> 
						<!-- Use: style="margin:2px; padding:2px; border:2px solid #cccccc; display:none;" -->
						Your browser does not support the HTML5 canvas tag.
					</canvas>
					</center>
					</div>
				</center>
				</td></tr>
		    <tr><td>
				<center>
				<table> <!-- Start of Virtual Machine Controls -->
					<tr>
					<!-- Memory Controls -->
					<td>
					<center>
					  <input type="button" name="memup"  value="⇧"  onclick="mem_top = 0x0000; update_display();"></input></br>
					  <input type="button" name="memup"  value="↟"  onclick="mem_top = Math.max(0,mem_top-1024); update_display();"></input></br>
					  <input type="button" name="memup"  value="↟"  onclick="mem_top = Math.max(0,mem_top-16); update_display();"></input></br>
					  <input type="button" name="memup"  value="↑"  onclick="mem_top = Math.max(0,mem_top-2); update_display();"></input></br>
					  <input type="button" name="memup"  value="⌂"  onclick="mem_top = 0x0200; update_display();"></input></br>
					  <input type="button" name="memdn"  value="↓"  onclick="mem_top = Math.min(0xffe0,mem_top+2); update_display();"></input></br>
					  <input type="button" name="memdn"  value="⇓"  onclick="mem_top = Math.min(0xffe0,mem_top+16); update_display();"></input></br>
					  <input type="button" name="memdn"  value="⇓"  onclick="mem_top = Math.min(0xffe0,mem_top+1024); update_display();"></input></br>
					  <input type="button" name="memdn"  value="⇩"  onclick="mem_top = 0xffe0; update_display();"></input></br>
					</center>
					</td>
					<!-- Memory table -->
					<td style="vertical-align: top;">
						<table class="mem">
							<tr class="mem"><td class="mem" id="A0"></td><td class="mem"><input type="text" id="M0" class="mem" name="M0" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A1"></td><td class="mem"><input type="text" id="M1" class="mem" name="M1" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A2"></td><td class="mem"><input type="text" id="M2" class="mem" name="M2" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A3"></td><td class="mem"><input type="text" id="M3" class="mem" name="M3" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A4"></td><td class="mem"><input type="text" id="M4" class="mem" name="M4" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A5"></td><td class="mem"><input type="text" id="M5" class="mem" name="M5" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A6"></td><td class="mem"><input type="text" id="M6" class="mem" name="M6" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A7"></td><td class="mem"><input type="text" id="M7" class="mem" name="M7" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A8"></td><td class="mem"><input type="text" id="M8" class="mem" name="M8" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A9"></td><td class="mem"><input type="text" id="M9" class="mem" name="M9" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AA"></td><td class="mem"><input type="text" id="MA" class="mem" name="MA" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AB"></td><td class="mem"><input type="text" id="MB" class="mem" name="MB" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AC"></td><td class="mem"><input type="text" id="MC" class="mem" name="MC" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AD"></td><td class="mem"><input type="text" id="MD" class="mem" name="MD" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AE"></td><td class="mem"><input type="text" id="ME" class="mem" name="ME" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AF"></td><td class="mem"><input type="text" id="MF" class="mem" name="MF" size="4"></td></tr>
						</table>
					</td>
					<!-- Register table -->
					<td style="vertical-align: top;">
						<table class="reg">
							<tr class="reg"><td class="reg">V0</td><td class="reg"><input type="text" id="V0" class="reg" name="V0" size="2"></td></tr>
							<tr class="reg"><td class="reg">V1</td><td class="reg"><input type="text" id="V1" class="reg" name="V1" size="2"></td></tr>
							<tr class="reg"><td class="reg">V2</td><td class="reg"><input type="text" id="V2" class="reg" name="V2" size="2"></td></tr>
							<tr class="reg"><td class="reg">V3</td><td class="reg"><input type="text" id="V3" class="reg" name="V3" size="2"></td></tr>
							<tr class="reg"><td class="reg">V4</td><td class="reg"><input type="text" id="V4" class="reg" name="V4" size="2"></td></tr>
							<tr class="reg"><td class="reg">V5</td><td class="reg"><input type="text" id="V5" class="reg" name="V5" size="2"></td></tr>
							<tr class="reg"><td class="reg">V6</td><td class="reg"><input type="text" id="V6" class="reg" name="V6" size="2"></td></tr>
							<tr class="reg"><td class="reg">V7</td><td class="reg"><input type="text" id="V7" class="reg" name="V7" size="2"></td></tr>
							<tr class="reg"><td class="reg">V8</td><td class="reg"><input type="text" id="V8" class="reg" name="V8" size="2"></td></tr>
							<tr class="reg"><td class="reg">V9</td><td class="reg"><input type="text" id="V9" class="reg" name="V9" size="2"></td></tr>
							<tr class="reg"><td class="reg">VA</td><td class="reg"><input type="text" id="VA" class="reg" name="VA" size="2"></td></tr>
							<tr class="reg"><td class="reg">VB</td><td class="reg"><input type="text" id="VB" class="reg" name="VB" size="2"></td></tr>
							<tr class="reg"><td class="reg">VC</td><td class="reg"><input type="text" id="VC" class="reg" name="VC" size="2"></td></tr>
							<tr class="reg"><td class="reg">VD</td><td class="reg"><input type="text" id="VD" class="reg" name="VD" size="2"></td></tr>
							<tr class="reg"><td class="reg">VE</td><td class="reg"><input type="text" id="VE" class="reg" name="VE" size="2"></td></tr>
							<tr class="reg"><td class="reg">VF</td><td class="reg"><input type="text" id="VF" class="reg" name="VF" size="2"></td></tr>
						</table>
					</td>
					<!-- PC and [I] table -->
					<td style="vertical-align: top;">
						<table>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">PC</td><td class="reg"><input type="text" id="PC" class="reg" name="PC" size="4"></td></tr>
									</table>
								</td>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg"><input type="text" id="PCINST" class="regleft" name="PCINST" size="12"></td></tr>
									</table>
								</td>
							</tr>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">SP</td><td class="reg"><input type="text" id="SP" class="reg" name="SP" size="4"></td></tr>
									</table>
								</td>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">&nbsp;N&nbsp;</td><td class="reg"><input type="text" id="N" class="reg" name="N" size="9" readonly></td></tr>
									</table>
								</td>
							</tr>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">[ I ]</td><td class="reg"><input type="text" id="[I]" class="reg" name="[I]" size="4"></td></tr>
									</table>
								</td>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">ST</td><td class="reg"><input type="text" id="ST" class="reg" name="ST" size="9"></td></tr>
									</table>
								</td>
							</tr>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">&nbsp;</td><td class="reg"></td></tr>
									</table>
								</td>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">CT</td><td class="reg"><input type="text" id="CT" class="reg" name="CT" size="9"></td></tr>
									</table>
								</td>
							</tr>
						</table>
					</td>
					</tr>
				</table> <!-- End of Virtual Machine Controls -->
				</center>
				</td></tr>
				</table>
		    </center>
			</td>  <!-- End of VIRTUAL MACHINE -->

		</tr>
	</tbody>
</table>

<p/><hr/><p/>


<b>Examples:</b>
<select id="example_select" onchange="on_example_change()">
<option value="none" selected>-- Select --</option>
</select>
<!-- <button type="button" onclick="on_example_change();">Load</button> -->
<input type="button" name="run"  value="Run"  onclick="assemble(); load(); reset(); run();"></input>

 &nbsp; &nbsp; &nbsp; <b>Documentation:</b>
<select id="show_help" onchange="on_doc_change()">
<option value="none" selected>-- Select --</option>
<option value="introduction">Introduction</option>
<option value="instruction_set">Instruction Set</option>
<option value="hex_to_binary">Hex to Binary</option>
<option value="examples">Examples</option>
</select>
<button type="button" onclick="on_doc_change();">Show</button>


<p/><hr/><p/>

<!-- for some reason, there are at least 3 unmatched "center" tags above that should be closed! -->
</center>
</center>
</center>


<div id="none" hidden></div>


<div id="introduction" hidden>
<center><h2>Introduction</h2></center>

This Javascript/HTML program implements a version of the CHIP-8 programming environment.
<br></br>
CHIP-8 source code can be entered in the "<b>Source Code</b>" text area. It can be assembled into the
"<b>Machine Code</b>" text area. From there it can be loaded into the simulator and run. The CHIP-8
screen is 64 x 32 (or 40 x 20 in hex).
<br></br>
<center><h3>Top row buttons: Assembling, Loading, Running)</h3></center>

The "<b>Assemble</b>" button assembles the source code and produces machine code.
<br></br>
The "<b>Save</b>" button saves a copy of the source window internally (it may be lost if you leave the page).
<br></br>
The "<b>Restore</b>" button restores the internally saved copy of the source window.
<br></br>
The "<b>Diassemble as</b>" button will disassemble from the Machine Code window into the Source Code window
(over-writing any text already in the Source Code window). The format of the disassembly is governed
by the selector which is one of the following:
<ul>
<li><b>Src</b>: Generates only source - can be reassembled.</li>
<li><b>L+S</b>: Generates labels and source - can be reassembled.</li>
<li><b>H+S</b>: Generates hex and source - cannot be reassembled.</li>
<li><b>LHS</b>: Generates labels, hex, and source - cannot be reassembled.</li>
</ul>

The "<b>Load</b>" button will load the hex values in the "Machine Code" window into the memory of the simulation.
You will see the machine code in the memory area below the graphics window.
<br></br>

The "<b>Reset</b>" button clears the graphics output and set all registers to their default state.
<br></br>

The "<b>Step</b>" button will run a single CHIP-8 instruction and then stop.
<br></br>

The "<b>Run</b>" button will run 1000 CHIP-8 instructions and then stop.
<br></br>

The "<b>Stop</b>" button is not currently implemented.
<br></br>

Finally the "Assemble, Load, Run" button ("<b>↻</b>") does all three. It's most useful during rapid development.
<br></br>

<center><h3>Examples</h3></center>
The "Examples" control allows selecting from a number of example programs.
Selecting any of the examples from the selection menu will replace the
current code with that example. BE SURE YOUR CODE IS SAVED FIRST!! Once
an example is loaded, it can be easily run with the "Run" button.

<center><h3>Documentation</h3></center>
The "Documentation" control allows selecting from a number of topics.
If the topic doesn't show for some reaon, try clicking the "Show" button.
Among other things, the full CHIP-8 instruction set and all of the examples
are available via the Documentation control.

<center><h3>Limitations</h3></center>

<ol>
<li>Hex values should be entered with the proper number of digits
(1 for a nibble, 2 for a byte, 3 for a CHIP-8 address, and 4 for a full address).
Any other number of digits (too many or too few) will cause assembly problems.
</li>
<li>Several instructions haven't been implemented yet.
</li>
<li>There is no asynchronous (threaded) support yet.
When you click the "Run" button, it will run 1000 instructions and ignore
the user interface (freeze) until it's done.
</li>
<li>The "Stop" button isn't implemented yet.
</li>
<li>There is no current support for either input (keyboard instructions) or sound.
</li>

<hr/>

</div>


<div id="instruction_set" hidden>

<p/>
<center>
=== Instruction Set and Assembler Syntax === <!-- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM -->
<table><tr><td>
<tt>
<pre>
Code   Assembly           Description - All numbers are hexadecimal
----   --------           -----------------------------------------
       lbl:               &#x2705; A label - must not match any other string in the program!
nnnn - DATA nnnn          &#x2705; Initialize a data word (all values in hex)

0nnn - SYS addr           &#x274C; Jump to a machine code routine at nnn.
00E0 - CLS                &#x2705; Clear the display.
00EE - RET                &#x2705; Return from a subroutine.
1nnn - JP addr            &#x2705; Jump to location nnn.
2nnn - CALL addr          &#x2705; Call subroutine at nnn.
3xkk - SE Vx, byte        &#x2705; Skip If Equal Immediate: Skip next instruction if Vx = kk.
4xkk - SNE Vx, byte       &#x2705; Skip If Not Equal Immediate: Skip next instruction if Vx != kk.
5xy0 - SE Vx, Vy          &#x2705; Skip If Equal Register: Skip next instruction if Vx = Vy.
6xkk - LD Vx, byte        &#x2705; Load Immediate: Set Vx = kk.
7xkk - ADD Vx, byte       &#x2705; Add Immediate: Set Vx = Vx + kk.
8xy0 - LD Vx, Vy          &#x2705; Load Register: Set Vx = Vy.
8xy1 - OR Vx, Vy          &#x2705; Or Register: Set Vx = Vx OR Vy.
8xy2 - AND Vx, Vy         &#x2705; And Register: Set Vx = Vx AND Vy.
8xy3 - XOR Vx, Vy         &#x2705; XOR Register: Set Vx = Vx XOR Vy.
8xy4 - ADD Vx, Vy         &#x2705; Add Register: Set Vx = Vx + Vy, set VF = carry.
8xy5 - SUB Vx, Vy         &#x2705; Sub Register: Set Vx = Vx - Vy, set VF = NOT borrow.
8xy6 - SHR Vx {, Vy}      &#x2705; Shift Right: Set Vx = Vx SHR 1.
8xy7 - SUBN Vx, Vy        &#x2705; Sub Negative Register: Set Vx = Vy - Vx, set VF = NOT borrow.
8xyE - SHL Vx {, Vy}      &#x2705; Shift Left: Set Vx = Vx SHL 1.
9xy0 - SNE Vx, Vy         &#x2705; Skip If Not Equal: Skip next instruction if Vx != Vy.
Annn - LD I, addr         &#x2705; Load I Immediate: Set I = nnn.
Bnnn - JP V0, addr        &#x2705; Jump to V0 with offset nnn.
Cxkk - RND Vx, byte       &#x2705; Rand: Set Vx to a random number (0 to 255) AND byte value.
Dxyn - DRW Vx, Vy, n      &#x2705; Draw: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
Ex9E - SKP Vx             &#x274C; Skip if Key[Vx]: Skip next instruction if key with the value of Vx is pressed.
ExA1 - SKNP Vx            &#x274C; Skip if !Key[Vx]: Skip next instruction if key with the value of Vx is not pressed.
Fx07 - LD Vx, DT          &#x274C; Load Vx from Delay Timer: Set Vx = delay timer value.
Fx0A - LD Vx, K           &#x274C; Load Vx from next Key: Wait for a key press, store the value of the key in Vx.
Fx15 - LD DT, Vx          &#x274C; Load Delay Timer from Vx: Set delay timer = Vx.
Fx18 - LD ST, Vx          &#x274C; Load Sound Timer from Vx: Set sound timer = Vx.
Fx1E - ADD I, Vx          &#x2705; Add Vx to I: Set I = I + Vx.
Fx29 - LD F, Vx           &#x2705; Load I from Sprite location: Set I = location of sprite for digit Vx.
Fx33 - LD B, Vx           &#x274C; Load BCD from X into Memory[I]: Store BCD representation of Vx in memory locations I, I+1, and I+2.
Fx55 - LD [I], Vx         &#x274C; Save Registers: Store registers V0 through Vx in memory starting at location I.
Fx65 - LD Vx, [I]         &#x274C; Restore Register: Read registers V0 through Vx from memory starting at location I.
</pre>
</tt>
</td></tr></table>
<hr/>
</center>
</div>


<div id="hex_to_binary" hidden>


<h3>CHIP-8 Program File Format (.ch8)</h3>

The common ".ch8" files used with CHIP-8 contain binary data which is more difficult to handle through a typical
web browser interface. For that reason, this program uses hexadecimal (hex) representations of binary files so they
can be easily copied and pasted. So to run a binary ".ch8" file, it must be converted to hex first. There are many
programs that can do this conversion. One of the most common is the UNIX/Linux "od" (octal dump) command. You can
use "od" to convert a binary ".ch8" file to a hexadecimal file with:<br/>
<br/>
$ od -v -tx1 -An filename<br/>
<br/>
For example:<br/>
<br/>
<tt>
$ od -v -tx1 -An Maze.ch8<br/>
a2 1e c2 01 32 01 a2 1a d0 14 70 04 30 40 12 00<br/>
60 00 71 04 31 20 12 00 12 18 80 40 20 10 20 40<br/>
80 10
</tt>
<br/>
<br/>
That output can be copied and pasted into the "Machine Code" window of this CHIP-8 simulator to run.
<hr/>

</div>




<div id="instruction_set" hidden>

<h3>RCA 1802 Instruction Set</h3>

<p/>
<hr/>
<p/>

</div>

<div id="examples" hidden>

<center>
<table>
<tr><th><h3>Example Programs</h3></th></tr>
<tr><td>
<table class="ex">

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Generate a Maze">
;===========================;
; Generate a maze in CHIP-8 ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;   V2 used for random bit  ;
;===========================;

TOP: LD I,R3      ; Load sprite address
     RND V2,01    ; Put random bit in V2
     SE V2,01     ; Skip if V2=1 (random)
     LD I,R1      ; Load a different sprite
     DRW V0,V1,4  ; Draw at (V0,V1) 4 rows
     ADD V0,04    ; Add 4 to x coord
     SE V0,40     ; Skip if at end of V0
     JP TOP       ; Go back to top
     LD V0,00     ; At end so go back x=0
     ADD V1,04    ; Add 4 to y
     SE V1,20     ; Skip if end of y (done)
     JP TOP       ; Go back to top
END: JP END       ; Stay here ... forever

R1:  DATA 8040    ; Image data
R2:  DATA 2010    ; Image data
R3:  DATA 2040    ; Image data
R4:  DATA 8010    ; Image data
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw small box">
;===========================;
; Draw small box in CHIP-8  ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD I,BX      ; Load sprite address
     LD V0,1B     ; Load x
     LD V1,0B     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
END: JP END       ; Stay here ... forever
BX:  DATA FF81    ; Image data FF is top, 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 81FF    ; Image data 81 is sides, FF is bottom
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw XOR box">
;===========================;
;  Draw XOR box in CHIP-8   ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP:   LD V0,1E     ; Load x
       LD V1,0E     ; Load y
       LD VA,01     ; Load increment of 1
       CALL PIX     ; Call the PIX Subroutine

LOOP:  ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine

       ADD V1,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine

       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine

       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine

       JP LOOP

PIX:   LD I,PX      ; Load sprite address
       DRW V0,V1,1  ; Draw at (V0,V1) 8 rows
       RET

PX:    DATA 8000    ; Image data leftmost bit set


</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw boxes in-line">
;===========================;
; Generate boxes in CHIP-8  ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD I,BX      ; Load sprite address
     LD V0,0D     ; Load x
     LD V1,05     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
END: JP END       ; Stay here ... forever
BX:  DATA FF81    ; Image data
     DATA 8181    ; Image data
     DATA 8181    ; Image data
     DATA 81FF    ; Image data
</pre></td></tr>

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw boxes via subroutine">
;===========================;
; Draw boxes via subroutine ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD V0,01     ; Load x
     LD V1,01     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,37     ; Load x
     LD V1,01     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,01     ; Load x
     LD V1,17     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,37     ; Load x
     LD V1,17     ; Load y
     CALL BOX     ; Call the Box Subroutine

END: JP END       ; Stay here ... forever

BOX: LD I,BX      ; Load sprite address
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     RET

BX:  DATA FF81    ; Image data FF is top, 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 81FF    ; Image data 81 is sides, FF is bottom
</pre></td></tr>

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw large box">
;================================;
; Generate a large box in CHIP-8 ;
;================================;
; Registers:                     ;
;   V0 used for x                ;
;   V1 used for y                ;
;================================;

TOP: LD I,HZ      ; Load sprite address

     LD V0,04     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,0C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,14     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,1C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,24     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,2C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,34     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD I,VT      ; Load sprite address

     LD V0,3B     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row
     LD V0,3B     ; Load x
     LD V1,0C     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row
     LD V0,3B     ; Load x
     LD V1,14     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row

     LD I,HZ      ; Load sprite address

     LD V0,34     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,2C     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,24     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,1C     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,14     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,0C     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row
     LD V0,04     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD I,VT      ; Load sprite address

     LD V0,04     ; Load x
     LD V1,13     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row
     LD V0,04     ; Load x
     LD V1,0B     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row
     LD V0,04     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row


END: JP END       ; Stay here ... forever

HZ:  DATA FF00    ; Horizontal
VT:  DATA 8080    ; Vertical
     DATA 8080    ; Vertical
     DATA 8080    ; Vertical
     DATA 8080    ; Vertical
</pre></td></tr>

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw CHIP-8 Digits">
;===========================;
;    Draw CHIP-8 Digits     ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

        ; TEST LD
        ; TEST CALL
        ; TEST RET
TOP:    CLS

        ; TEST the 16 numeric sprites with 2 loops

        LD VA,05     ; Amount to increment I (size of glyphs)
        LD F,V0      ; Puts address of '0' in I
        LD V5,08     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop1: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
				ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop1   ; Continue with next glyph


        LD V5,13     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop2: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
				ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop2   ; Continue with next glyph

END:    JP END       ; Stay here ... forever
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="CHIP-8 Test Suite">
;===========================;
;     CHIP-8 Test Suite     ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

        ; TEST LD
        ; TEST CALL
        ; TEST RET
TOP:    LD V0,01     ; Load x
        LD V1,01     ; Load y
        CALL BOX     ; Call the Box Subroutine

        ; TEST CLS
        CLS          ; Clear after first to test CLS

        LD V0,37     ; Load x
        LD V1,01     ; Load y
        CALL BOX     ; Call the Box Subroutine

        LD V0,01     ; Load x
        LD V1,17     ; Load y
        CALL BOX     ; Call the Box Subroutine

        LD V0,37     ; Load x
        LD V1,17     ; Load y
        CALL BOX     ; Call the Box Subroutine

        ; Screen should show 3 blocks since first was cleared
        ; Now that 3 blocks are drawn, use CLR to show failure


        ; TEST the 16 numeric sprites with 2 loops

        LD VA,05     ; Amount to increment I (size of glyphs)
        LD F,V0      ; Puts address of '0' in I
        LD V5,0A     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop1: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
				ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop1   ; Continue with next glyph


        LD V5,11     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop2: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
				ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop2   ; Continue with next glyph


        ; TEST JP
        JP JPOK
        CLS          ; Clear if JP fails

        ; TEST SE immediate
JPOK:   LD V0,55
        SE V0,55     ; Test SE skipping when equal
        CLS
        SE V0,44     ; Test SE not skipping when not equal
        SE V0,55     ; Test SE skipping when equal
        CLS

        ; TEST SNE immediate
        LD V0,55
        SNE V0,44    ; Test SNE skipping when not equal
        CLS
        SNE V0,55    ; Test SNE not skipping when equal
        SE V0,55
        CLS

        ; TEST SNE register
        LD V0,55
        LD V4,44
        SNE V0,V4    ; Test SNE skipping when not equal
        CLS
        LD V4,55
        SNE V0,V4    ; Test SNE not skipping when equal
        SE V0,55
        CLS

        ; TEST SE register
        LD V0,55
        LD V4,44
        LD V5,55
        SE V0,V5     ; Test SE skipping when equal
        CLS
        SE V0,V4     ; Test SE not skipping when not equal
        SE V0,55     ; Test SE skipping when equal
        CLS

        ; TEST LD register to register
        LD V0,00
        LD V5,55
        LD V0,V5
        SE V0,55
        CLS

        ; TEST OR Vx,Vy (Vx = Vx | Vy)
        LD V4,94     ; 10010100 = 94
        LD V5,CE     ; 11001110 = CE
        OR V5,V4
        SE V5,DE     ; 11011110 = DE
        CLS

        ; TEST AND Vx,Vy (Vx = Vx & Vy)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,EE    ; 11101110 = EE
        AND V5,V4
        SE  V5,A4    ; 10100100 = A4
        CLS

        ; TEST XOR Vx,Vy (Vx = Vx ^ Vy)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,ED    ; 11101101 = ED
        XOR V5,V4
        SE  V5,59    ; 01011001 = 59
        CLS

        ; TEST ADD Vx,Vy (Vx = Vx + Vy)
        LD  V4,34    ; 00110100 = 34
        LD  V5,6D    ; 01101101 = 6D
        ADD V5,V4
        SE  V5,A1    ; 10100001 = A1
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD  V4,34    ; 00110100 = 34
        LD  V5,6D    ; 01101101 = 6D
        ADD V5,V4
        SE  V5,A1    ; 10100001 = A1
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD  V4,A1    ; 10100001 = A1
        LD  V5,6D    ; 01101101 = 6D
        SUB V4,V5
        SE  V4,34    ; 00110100 = 34
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD   V4,A1   ; 10100001 = A1
        LD   V5,6D   ; 01101101 = 6D
        SUBN V5,V4
        SE   V5,34   ; 00110100 = 34
        CLS

        ; TEST SHR Vx,Vy (Vx = Vy >> 1)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,A7    ; 10100111 = A7
        SHR V5,V4
        SE  V5,5A    ; 01011010 = 5A
        CLS

        ; TEST SHR Vx,Vy (Vx = Vy >> 1)
        LD  V5,A7    ; 10100111 = A7
        SHR V5,V5
        SE  V5,53    ; 01010011 = 53
        CLS

        ; TEST SHL Vx,Vy (Vx = Vy LL 1) LL replaces ((
        LD  V4,08    ; 00001000 = 08
        LD  V5,AA    ; 10101010 = AA
        SHL V5,V4
        SE  V5,10    ; 00010000 = 10
        CLS

        ; TEST SHL Vx,Vy (Vx = Vy LL 1) LL replaces ((
        LD  V5,A7    ; 10100111 = A7
        SHL V5,V5
        SE  V5,4E    ; 01001110 = 4E
        CLS


END:    JP END       ; Stay here ... forever

BOX:    LD I,BX      ; Load sprite address
        DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
        RET

BX:     DATA FF81    ; Image data FF is top, 81 is sides
        DATA 8181    ; Image data 81 is sides
        DATA 8181    ; Image data 81 is sides
        DATA 81FF    ; Image data 81 is sides, FF is bottom
</pre></td></tr>

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Tetris">
200: LD I,2B4
202: CALL 3E6
204: CALL 2B6
206: ADD V0,01
208: DRW V0,V1,1
20A: SE V0,25
20C: JP 206
20E: ADD V1,FF
210: DRW V0,V1,1
212: LD V0,1A
214: DRW V0,V1,1
216: LD V0,25
218: SE V1,00
21A: JP 20E
21C: RND V4,70
21E: SNE V4,70
220: JP 21C
222: RND V3,03
224: LD V0,1E
226: LD V1,03
228: CALL 25C
22A: LD DT,V5
22C: DRW V0,V1,4
22E: SE VF,01
230: JP 23C
232: DRW V0,V1,4
234: ADD V1,FF
236: DRW V0,V1,4
238: CALL 340
23A: JP 21C
23C: SKNP V7
23E: CALL 272
240: SKNP V8
242: CALL 284
244: SKNP V9
246: CALL 296
248: SKP V2
24A: JP 250
24C: LD V6,00
24E: LD DT,V6
250: LD V6,DT
252: SE V6,00
254: JP 23C
256: DRW V0,V1,4
258: ADD V1,01
25A: JP 22A
25C: LD I,2C4
25E: ADD I,V4
260: LD V6,00
262: SNE V3,01
264: LD V6,04
266: SNE V3,02
268: LD V6,08
26A: SNE V3,03
26C: LD V6,0C
26E: ADD I,V6
270: RET
272: DRW V0,V1,4
274: ADD V0,FF
276: CALL 334
278: SE VF,01
27A: RET
27C: DRW V0,V1,4
27E: ADD V0,01
280: CALL 334
282: RET
284: DRW V0,V1,4
286: ADD V0,01
288: CALL 334
28A: SE VF,01
28C: RET
28E: DRW V0,V1,4
290: ADD V0,FF
292: CALL 334
294: RET
296: DRW V0,V1,4
298: ADD V3,01
29A: SNE V3,04
29C: LD V3,00
29E: CALL 25C
2A0: CALL 334
2A2: SE VF,01
2A4: RET
2A6: DRW V0,V1,4
2A8: ADD V3,FF
2AA: SNE V3,FF
2AC: LD V3,03
2AE: CALL 25C
2B0: CALL 334
2B2: RET
2B4: LD V0,V0
2B6: LD V7,05
2B8: LD V8,06
2BA: LD V9,04
2BC: LD V1,1F
2BE: LD V5,10
2C0: LD V2,07
2C2: RET
2C4: SNE V0,E0
2C6: SYS 000
2C8: SNE V0,C0
2CA: SNE V0,00
2CC: CLS
2CE: SNE V0,00
2D0: SNE V0,60
2D2: SNE V0,00
2D4: SNE V0,40
2D6: LD V0,00
2D8: CALL 0E0
2DA: SYS 000
2DC: RND V0,40
2DE: SNE V0,00
2E0: CLS
2E2: LD V0,V0
2E4: SNE V0,40
2E6: RND V0,00
2E8: CLS
2EA: CALL 000
2EC: LD V0,40
2EE: SNE V0,00
2F0: LD V0,VE
2F2: SYS 000
2F4: SNE V0,C0
2F6: LD V0,V0
2F8: RND V0,60
2FA: SYS 000
2FC: SNE V0,C0
2FE: LD V0,V0
300: RND V0,60
302: SYS 000
304: LD V0,VC
306: SNE V0,00
308: SYS 060
30A: RND V0,00
30C: LD V0,VC
30E: SNE V0,00
310: SYS 060
312: RND V0,00
314: RND V0,C0
316: SYS 000
318: RND V0,C0
31A: SYS 000
31C: RND V0,C0
31E: SYS 000
320: RND V0,C0
322: SYS 000
324: SNE V0,40
326: SNE V0,40
328: SYS 0F0
32A: SYS 000
32C: SNE V0,40
32E: SNE V0,40
330: SYS 0F0
332: SYS 000
334: DRW V0,V1,4
336: LD V6,35
338: ADD V6,FF
33A: SE V6,00
33C: JP 338
33E: RET
340: LD I,2B4
342: LD VC,V1
344: SE VC,1E
346: ADD VC,01
348: SE VC,1E
34A: ADD VC,01
34C: SE VC,1E
34E: ADD VC,01
350: CALL 35E
352: SNE VB,0A
354: CALL 372
356: SNE V1,VC
358: RET
35A: ADD V1,01
35C: JP 350
35E: LD V0,1B
360: LD VB,00
362: DRW V0,V1,1
364: SE VF,00
366: ADD VB,01
368: DRW V0,V1,1
36A: ADD V0,01
36C: SE V0,25
36E: JP 362
370: RET
372: LD V0,1B
374: DRW V0,V1,1
376: ADD V0,01
378: SE V0,25
37A: JP 374
37C: LD VE,V1
37E: LD VD,VE
380: ADD VE,FF
382: LD V0,1B
384: LD VB,00
386: DRW V0,VE,1
388: SE VF,00
38A: JP 390
38C: DRW V0,VE,1
38E: JP 394
390: DRW V0,VD,1
392: ADD VB,01
394: ADD V0,01
396: SE V0,25
398: JP 386
39A: SNE VB,00
39C: JP 3A6
39E: ADD VD,FF
3A0: ADD VE,FF
3A2: SE VD,01
3A4: JP 382
3A6: CALL 3C0
3A8: SE VF,01
3AA: CALL 3C0
3AC: ADD VA,01
3AE: CALL 3C0
3B0: LD V0,VA
3B2: LD VD,07
3B4: AND V0,VD
3B6: SNE V0,04
3B8: ADD V5,FE
3BA: SNE V5,02
3BC: LD V5,04
3BE: RET
3C0: LD I,700
3C2: LD [I],V2
3C4: LD I,804
3C6: LD B,VA
3C8: LD V2,[I]
3CA: LD F,V0
3CC: LD VD,32
3CE: LD VE,00
3D0: DRW VD,VE,5
3D2: ADD VD,05
3D4: LD F,V1
3D6: DRW VD,VE,5
3D8: ADD VD,05
3DA: LD F,V2
3DC: DRW VD,VE,5
3DE: LD I,700
3E0: LD V2,[I]
3E2: LD I,2B4
3E4: RET
3E6: LD VA,00
3E8: LD V0,19
3EA: RET
3EC: SE V7,23
</pre></td></tr>

</table>
</td></tr>
</table>

</center>

<hr/>

</div>


</body>

</html>

