<!DOCTYPE html>
<html>

<head>
<title>CHIP-8 Development Environment</title>
<meta charset="utf-8"/>
</head>

<style>
table.reg,table.mem {
  font-size: 110%;
  border: 1px solid black;
  border-collapse: collapse;
  /* border-spacing: 0px; */
}
tr.reg,tr.mem {
  font-size: 110%;
  background-color: #000000;
  border: none;
  padding: 0px;
  margin: 0px;
}
td.reg,td.mem {
  font-size: 70%;
  background-color: #ffffff;
  border: 1px solid black;
  padding: 0px;
  padding-left: 4px;
  padding-right: 4px;
  margin: 0px;
  text-align: center;
  /*outline-width: 0px;*/
}
input.reg,input.mem {
  font-size: 110%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: right;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 12px;
  /*outline-width: 0px;*/
}
input.regleft {
  font-size: 110%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: left;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 12px;
  /*outline-width: 0px;*/
}
table.ex, th.ex, tr.ex, td.ex {
  border: 2px solid black;
  font-family: monospace;
  font-weight: bold;
  font-size: 100%;
  padding-top: 3px;
  padding-left: 5px;
  padding-right: 5px;
  padding-bottom: 1px;
  border-collapse: collapse;
}
th.ex {
  font-size: 120%;
}
</style>

<script>
debugging = false;  // Creates a text area during onload and fills while running

mem = [];
mem_top = 0x0200; // Address of memory shown at top of the memory list
V = [];
PC = 0x0200; // Program Counter typically starts at 0x0200
SP = 0x0001; // Set stack pointer at 1 since it is incremented before use
I = 0x0000;  // Index register
N = 0;       // Number of instructions since reset
T = 0;       // Timer Register
CT = 1;      // Clock Time (time per clock tick)
ST = 15;     // Steps per clock tick
DT = 11;     // Delay Time (time per delay count)

num_rows = 32;
num_cols = 64;
screen = [];
fg_color = "#AAAAff";
bg_color = "#000044";
font_addr = 0x0FA0;  // This could be anywhere but stack or program memory

assem_loaded_once = false;

function log_entry() {
  if (debugging) {
    logtextarea = document.getElementById("log");
    logtextarea.value += " PC:"+hex4(PC);
    logtextarea.value += " SP:"+hex4(SP);
    logtextarea.value += " I: "+hex4(I);
    logtextarea.value += " V:["+V.toString()+"]";
    logtextarea.value += "\n";
  }
}

function replaceAll ( s, t, r ) {
  new_s = (s + " ").trim();
  do {
    last_s = (new_s + " ").trim();
    new_s = last_s.replace(t,r);
  } while ( ! (new_s === last_s) );
  return ( new_s );
}

function pad0 (val, n) {
  v = val;
  while (v.length < n) {
    v = "0" + v;
  }
  return ( v );
}

function hex (val) {
  return ( val.toString(16).toUpperCase() );
}

function hex2 (val) {
  return ( pad0 ( val.toString(16).toUpperCase(), 2 ) );
}

function hex3 (val) {
  return ( pad0 ( val.toString(16).toUpperCase(), 3 ) );
}

function hex4 (val) {
  return ( pad0 ( val.toString(16).toUpperCase(), 4 ) );
}

function clear_screen() {
  // Clear the display memory
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      screen[r][c] = 0;
    }
  }
  draw_screen();
}

function draw_screen() {
  da = document.getElementById ("drawing_area");
  ctxt = da.getContext('2d');
  ctxt.fillStyle = bg_color;
  ctxt.fillRect(0, 0, da.width, da.height);
  ctxt.fillStyle = fg_color;
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      if (screen[r][c] != 0) {
        ctxt.fillRect(5*c, 5*r, 5, 5);
      }
    }
  }
}

function update_display() {
  update_variables();
  // Show the Memory starting with mem_top (even addresses)
  base_addr = 2 * Math.floor(mem_top/2);
  for (i=0; i<16; i++) {
    i_text = i.toString(16).toUpperCase().trim();
    addr = base_addr + (2*i);
    mem_val = (mem[addr] << 8) + mem[addr+1];
    document.getElementById("A"+i_text).innerHTML = hex4 ( addr );
    document.getElementById("M"+i_text).value = hex4 ( mem_val );
  }
  // Show the register values
  for (i=0; i<16; i++) {
    i_text = i.toString(16).toUpperCase().trim();
    v = "V" + i_text;
    document.getElementById(v).value = hex2 ( V[i] );
  }
  document.getElementById("PC").value = hex4 ( PC );
  document.getElementById("SP").value = hex4 ( SP );
  opcode = hex2(mem[PC]) + hex2(mem[PC+1])
  document.getElementById("PCINST").value = disassemble_line( opcode.trim() );
  document.getElementById("[I]").value = hex4 ( I );
  document.getElementById("N").value = N.toString();
  document.getElementById("ST").value = ST.toString();
  document.getElementById("CT").value = CT.toString();
  document.getElementById("DT").value = DT.toString();
}

function init_machine() {
  // Initialize the memory
  mem = [];
  for (i=0; i<0x10000; i++) {
    mem.push(0xFF);
  }
  // Load the Font data (80 bytes total)
  // Each entry is 4 columns x 5 rows
  // Sprites are 8 columns wide but
  // these only use the first 4 bits
  font_data = [
    [0xF0, 0x90, 0x90, 0x90, 0xF0], // 0
    [0x20, 0x60, 0x20, 0x20, 0x70], // 1
    [0xF0, 0x10, 0xF0, 0x80, 0xF0], // 2
    [0xF0, 0x10, 0xF0, 0x10, 0xF0], // 3
    [0x90, 0x90, 0xF0, 0x10, 0x10], // 4
    [0xF0, 0x80, 0xF0, 0x10, 0xF0], // 5
    [0xF0, 0x80, 0xF0, 0x90, 0xF0], // 6
    [0xF0, 0x10, 0x20, 0x40, 0x40], // 7
    [0xF0, 0x90, 0xF0, 0x90, 0xF0], // 8
    [0xF0, 0x90, 0xF0, 0x10, 0xF0], // 9
    [0xF0, 0x90, 0xF0, 0x90, 0x90], // A
    [0xE0, 0x90, 0xE0, 0x90, 0xE0], // B
    [0xF0, 0x80, 0x80, 0x80, 0xF0], // C
    [0xE0, 0x90, 0x90, 0x90, 0xE0], // D
    [0xF0, 0x80, 0xF0, 0x80, 0xF0], // E
    [0xF0, 0x80, 0xF0, 0x80, 0x80]  // F
  ];
  i = font_addr;
  // console.log ( "Loading Font Data" );
  for (r=0; r<font_data.length; r++) {
    for (c=0; c<font_data[r].length; c++) {
      mem[i] = font_data[r][c];
      i+=1;
    }
  }
  // Initialize the "V" registers
  V = [];
  for (i=0; i<16; i++) {
    V.push(0);
  }
  // Initialize the display memory
  screen = [];
  for (r=0; r<num_rows; r++) {
    row = [];
    for (c=0; c<num_cols; c++) {
      row.push(0);
    }
    screen.push(row)
  }
  document.getElementById("ST").value = ST.toString();
  document.getElementById("CT").value = CT.toString();
  document.getElementById("DT").value = DT.toString();
  update_display();
  draw_screen();
}

function load_menus() {
  example_menu = document.getElementById("example_select");
  ex = document.getElementsByClassName("exsrc");
  for (i=0; i<ex.length; i++) {
    opt = document.createElement ( "option" );
    opt.value = ex[i].id;
    opt.innerHTML = ex[i].id;
    example_menu.appendChild ( opt );
    // console.log ( "Example: " + ex[i].id );
  }
  ex = document.getElementsByClassName("exhex");
  for (i=0; i<ex.length; i++) {
    opt = document.createElement ( "option" );
    opt.value = "Hex:"+ex[i].id;
    opt.innerHTML = "Hex:"+ex[i].id;
    example_menu.appendChild ( opt );
    // console.log ( "Example: " + ex[i].id );
  }
}

function load_example() {
  // document.getElementById ( "source" ).value = document.getElementById("Generate a Maze").innerHTML;
  document.getElementById ( "source" ).value = document.getElementById("Tetris").innerHTML;
}

function onload() {
  load_menus();
  //load_example();
  selector = document.getElementById("example_select");
  selector[selector.selectedIndex].value = "Tetris";
  on_example_change();
  init_machine();
  clear_screen();
  window.addEventListener("keyup", handle_keyup);
  window.addEventListener("keydown", handle_keydn);
  // window.addEventListener("keypress", log);
  if (debugging) {
    plog = document.getElementById("plog");
    plog.innerHTML = '<textarea id="log" rows="1" cols="60" ' +
                     'autocomplete="off" autocorrect="off" autocapitalize="off" ' +
                     'spellcheck="false"></textarea><p/><hr/><p/>';
    logtextarea = document.getElementById("log");
    logtextarea.value = "";
  }
}

// Keymap starting at 7 (has problems with / key being intercepted)
keymap7 = {  '7':0, '8':1, '9':2, '0':3,
             'u':4, 'i':5, 'o':6, 'p':7,
              'j':8, 'k':9, 'l':10,';':11,
               'm':12,',':13,'.':14,'/':15  };
// Keymap starting at 6 (seems to work)
keymap = {  '6':0, '7':1, '8':2, '9':3,
             'y':4, 'u':5, 'i':6, 'o':7,
              'h':8, 'j':9, 'k':10,'l':11,
               'n':12,'m':13,',':14,'.':15  };

keydown = [ 0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0  ];

lastkey = null;
new_key = null;
key_wait = null;

function wait_for_key() {
  if (key_wait == null) {
    // First call
    lastkey = null;
    key_wait = setTimeout ( "wait_for_key()", 10 ); // pause_time_ms );
  } else {
    clearTimeout ( key_wait );
    if (lastkey == null) {
      // Keep waiting
      key_wait = setTimeout ( "wait_for_key()", 10 ); // pause_time_ms );
    } else {
      // Got a key
      new_key = lastkey;
      lastkey = null;
      key_wait = null;
    }
  }
}

button_remapping = false;
button_remap=[[4,8],[6,9],[1,10],[9,7],[5,0]]; // Tank
button_remap=[[4,2],[6,4],[5,6]]; // Tetris

// Tetris key mapping:
//  Keyboard "2" moves left
//  Keyboard "4" moves right
//  Keyboard "6" rotates
//
function bd(n,v) {
  // console.log ( "Button " + n + " is " + v );
  lastkey = n;
  if (button_remapping) {
    if ((n>=0) && (n<16)) {
      for (i=0; i<button_remap.length; i++) {
        if (n == button_remap[i][0]) {
          keydown[button_remap[i][1]] = v;
        }
      }
    }
  } else {
    keydown[n] = v;
  }
}

key_remapping = true;
key_remap = [[4,8],[6,9],[8,10],[2,7],[5,0]]; // Tank
key_remap = [[2,2],[4,7],[6,8],[5,9]]; // Tetris: unmapped: 2=drop  7=left  8=right  9 = rotate
key_remap = []

function kd(n,v) {
  // console.log ( "Key " + n + " is " + v );
  lastkey = n;
  if (key_remapping) {
    if ((n>=0) && (n<16)) {
      for (i=0; i<key_remap.length; i++) {
        if (n == key_remap[i][0]) {
          keydown[key_remap[i][1]] = v;
        }
      }
    }
  } else {
    keydown[n] = v;
  }
}

function handle_keydn(event) {
  kd(Number(event.key),1);
  /*
  if      (event.key == '4') {  keydown[8]  = 1; } // Left
  else if (event.key == '6') {  keydown[9]  = 1; } // Right
  else if (event.key == '8') {  keydown[10] = 1; } // Up
  else if (event.key == '2') {  keydown[7]  = 1; } // Down
  else if (event.key == '5') {  keydown[0]  = 1; } // Fire
  */
}

function handle_keyup(event) {
  kd(Number(event.key),0);
  /*
  if      (event.key == '4') {  keydown[8]  = 0; } // Left
  else if (event.key == '6') {  keydown[9]  = 0; } // Right
  else if (event.key == '8') {  keydown[10] = 0; } // Up
  else if (event.key == '2') {  keydown[7]  = 0; } // Down
  else if (event.key == '5') {  keydown[0]  = 0; } // Fire
  */
}

function showkeys() {
  console.log ( "====================================" );
  for (j=0; j<4; j++) {
    console.log ( j + ": " + keydown[(4*j)+0] + " " + keydown[(4*j)+1] + " " + keydown[(4*j)+2] + " " + keydown[(4*j)+3] );
  }
}



function changed_format() {
  // fmt = document.getElementById ("format_to").value;
  // console.log ("Format changed to " + fmt);
}

function get_b_comma_vx ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1);
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_b ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2);
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_vy ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_vy (" + s + ") = " + result );
  return ( result );
}

function assemble_text ( srctxt ) {
  // console.log ("Assemble code");
  // srctxt = document.getElementById ( "source" ).value;
  // console.log ( "Text = " + srctxt );

  if (srctxt.length == 0) return;

  // Initialize the binary text output
  bintxt = "";

  // Normalize line endings and remove empty lines
  text = replaceAll( srctxt, "\r", "\n");
  while (text.indexOf("\n\n") >= 0) {
    text = replaceAll(text, "\n\n", "\n");
  }
  // console.log ( text );
  // Convert all white space to spaces
  // text = text.replace(/\s+/g,' ');
  // Remove all double spaces
  while (text.indexOf("  ") >= 0) {
    text = replaceAll(text, "  ", " ");
  }
  // console.log ( text );
  // Split the text into an array of lines
  lines = text.split("\n");
  // console.log ( "lines=" + lines );

  // Remove all comments and empty lines
  new_lines = [];
  for (l=0; l<lines.length; l++) {
    line = lines[l].toUpperCase().trim();
    if (line.indexOf(";") >= 0) {
      // Remove the comment
      line = line.substr(0,line.indexOf(";")).trim();
    }
    if (line.trim().length > 0) {
      new_lines.push ( line.trim() );
    }
  }
  lines = new_lines;

  // Remove any and all last lines containing empty labels
  while ( lines[lines.length-1].indexOf(":") == (lines[lines.length-1].length-1) ) {
    // Copy all but the last line
    new_lines = [];
    for (l=0; l<(lines.length-1); l++) {
      new_lines[l] = lines[l];
    }
    lines = new_lines;
  }

  // Merge empty labels with subsequent lines
  new_lines = [];
  l = 0;
  while (l<lines.length) {
    line = lines[l];
    if (line.indexOf(":") == (line.length-1)) {
      // This is an empty label so join it with the next line
      l = l + 1;
      new_lines.push ( line + " " + lines[l] );
    } else {
      // Just push this line by itself
      new_lines.push ( line );
    }
    l = l + 1;
  }
  lines = new_lines;

  // Compute the label addresses
  label_dict = {};
  for (l=0; l<lines.length; l++) {
    line = lines[l].toUpperCase().trim();
    if (line.indexOf(":") >= 0) {
      // Store the label and its location
      label = line.substr(0,line.indexOf(":"));
      label_dict[label] = ((2*l)+0x200).toString(16);
      while (label_dict[label].length < 3) {
        label_dict[label] = '0' + label_dict[label];
      }
      // Remove the label from the line of code for assembly
      lines[l] = lines[l].substr(line.indexOf(":")+1).trim();
    }
  }
  keys = Object.keys(label_dict);
  // console.log ( "labels = " + keys );
  for (l=0; l<lines.length; l++) {
    for (ki=0; ki<keys.length; ki++) {
      // console.log ( "Searching for " + keys[ki] );
      lines[l] = replaceAll( lines[l].toUpperCase(), keys[ki], label_dict[keys[ki]]);
    }
  }

  // Process the lines one by one
  for (l=0; l<lines.length; l++) {
    line = lines[l].toUpperCase().trim();
    // line = lines[l].replace(/\s+/g,''); // Remove all white space
    if (line.indexOf(";") >= 0) {
      // Remove the comment
      line = line.substr(0,line.indexOf(";")).trim();
    }
    if (line.length > 0) {
      if (line.indexOf(":") >= 0) {
        // Throw away the labels for now
        line = line.substr(line.indexOf(":")+1).trim();
      }
      if (line.slice(0,5) == "DATA ") {
        bintxt += line.slice(5).trim() + "\n";
      } else if (line.slice(0,4) == "SYS ") {
        bintxt += "0" + line.slice(4).trim() + "\n";
      } else if (line.slice(0,3) == "CLS") {
        bintxt += "00E0\n";
      } else if (line.slice(0,3) == "RET") {
        bintxt += "00EE\n";
      } else if (line.slice(0,3) == "JP ") {
        // JP can take the following forms:
        //   JP nnn    -->  1nnn
        //   JP V0,nnn -->  Bnnn
        if (line.indexOf(",") >= 0) {
          bintxt += "B" + line.slice(line.indexOf(",")+1).trim() + "\n";
        } else {
          bintxt += "1" + line.slice(2).trim() + "\n";
        }
      } else if (line.slice(0,5) == "CALL ") {
        // CALL takes the following form:
        //   CALL nnn
        bintxt += "2" + line.slice(5).trim() + "\n";
      } else if (line.slice(0,3) == "SE ") {
        // SE (Skip when Equal) can take the following forms:
        //   SE Vx,byte -> 3xbb
        //   SE Vx,Vy   -> 5xy0
        if (line.split(",")[1].indexOf("V") < 0) {
          // SE Vx,byte -> 3xbb
          vb = get_vx_comma_b ( line.slice(3) );
          bintxt += "3" + vb[0] + vb[1] + "\n";
        } else {
          // SE Vx,Vy   -> 5xy0
          vv = get_vx_comma_vy ( line.slice(3) );
          bintxt += "5" + vv[0] + vv[1] + "0" + "\n";
        }
      } else if (line.slice(0,4) == "SNE ") {
        // SNE (Skip when Not Equal) can take the following forms:
        //   SNE Vx,byte -> 4xbb
        //   SNE Vx,Vy   -> 9xy0
        if (line.split(",")[1].indexOf("V") < 0) {
          // SNE Vx,byte -> 4xbb
          vb = get_vx_comma_b ( line.slice(3) );
          bintxt += "4" + vb[0] + vb[1] + "\n";
        } else {
          // SNE Vx,Vy   -> 9xy0
          vv = get_vx_comma_vy ( line.slice(3) );
          bintxt += "9" + vv[0] + vv[1] + "0" + "\n";
        }
      } else if (line.slice(0,3) == "LD ") {
        // LD (Load) can take the following forms:
        //   LD Vx,byte -> 6xbb
        //   LD Vx,Vy   -> 8xy0
        //   LD I,nnn   -> Annn
        //   LD Vx,DT   -> Fx07
        //   LD Vx,K    -> Fx0A
        //   LD DT,Vx   -> Fx15
        //   LD ST,Vx   -> Fx18
        //   LD F,Vx    -> Fx29
        //   LD B,Vx    -> Fx33
        //   LD [I],Vx  -> Fx55
        //   LD Vx,[I]  -> Fx65
        pars = line.slice(3).trim().split(",");
        pars[0] = pars[0].trim();
        pars[1] = pars[1].trim();
        // Handle the easy ones first
        if (pars[0] == "I") {
          // LD I,nnn   -> Annn
          bintxt += "A" + pars[1].trim() + "\n";
        } else if (pars[0] == "DT") {
          // LD DT,Vx   -> Fx15
          bintxt += "F" + pars[1].slice(1).trim() + "15\n";
        } else if (pars[0] == "ST") {
          // LD ST,Vx   -> Fx18
          bintxt += "F" + pars[1].slice(1).trim() + "18\n";
        } else if (pars[0] == "F") {
          // LD F,Vx    -> Fx29
          bintxt += "F" + pars[1].slice(1).trim() + "29\n";
        } else if (pars[0] == "B") {
          // LD B,Vx    -> Fx33
          bintxt += "F" + pars[1].slice(1).trim() + "33\n";
        } else if (pars[0] == "[I]") {
          // LD [I],Vx  -> Fx55
          bintxt += "F" + pars[1].slice(1).trim() + "55\n";
        } else if (pars[1] == "DT") {
          // LD Vx,DT   -> Fx07
          bintxt += "F" + pars[0].slice(1).trim() + "07\n";
        } else if (pars[1] == "K") {
          // LD Vx,K    -> Fx0A
        } else if (pars[1] == "[I]") {
          // LD Vx,[I]  -> Fx65
          bintxt += "F" + pars[0].slice(1).trim() + "65\n";
        } else {
          if (line.split(",")[1].indexOf("V") < 0) {
            // LD Vx,byte -> 6xbb
            vb = get_vx_comma_b ( line.slice(3) );
            bintxt += "6" + vb[0] + vb[1] + "\n";
          } else {
            // LD Vx,Vy   -> 8xy0
            vv = get_vx_comma_vy ( line.slice(3) );
            bintxt += "8" + vv[0] + vv[1] + "0" + "\n";
          }
        }
      } else if (line.slice(0,4) == "ADD ") {
        // ADD can take the following forms:
        //   ADD Vx,byte -> 7xbb
        //   ADD Vx,Vy   -> 8xy4
        //   ADD I,Vx    -> Fx1E
        pars = line.slice(3).trim().split(",");
        pars[0] = pars[0].trim();
        pars[1] = pars[1].trim();
        if (pars[0] == "I") {
          // ADD I,Vx    -> Fx1E
          bintxt += "F" + pars[1].slice(1).trim() + "1E\n";
        } else {
          if (pars[1].indexOf("V") < 0) {
            // ADD Vx,byte -> 7xbb
            vb = get_vx_comma_b ( line.slice(3) );
            bintxt += "7" + vb[0] + vb[1] + "\n";
          } else {
            // ADD Vx,Vy   -> 8xy0
            vv = get_vx_comma_vy ( line.slice(3) );
            bintxt += "8" + vv[0] + vv[1] + "4" + "\n";
          }
        }
      } else if (line.slice(0,3) == "OR ") {
        vv = get_vx_comma_vy ( line.slice(2).trim() );
        bintxt += "8" + vv[0] + vv[1] + "1" + "\n";
      } else if (line.slice(0,4) == "AND ") {
        vv = get_vx_comma_vy ( line.slice(3).trim() );
        bintxt += "8" + vv[0] + vv[1] + "2" + "\n";
      } else if (line.slice(0,4) == "XOR ") {
        vv = get_vx_comma_vy ( line.slice(3).trim() );
        bintxt += "8" + vv[0] + vv[1] + "3" + "\n";
      } else if (line.slice(0,4) == "SUB ") {
        vv = get_vx_comma_vy ( line.slice(3).trim() );
        bintxt += "8" + vv[0] + vv[1] + "5" + "\n";
      } else if (line.slice(0,4) == "SHR ") {
        if (line.indexOf(",") >= 0) {
          // SHR Vx,Vy
          vv = get_vx_comma_vy ( line.slice(3).trim() );
          if (vv[0].length <= 0) {
            vv[0] = "?";
          }
        } else {
          // SHR Vx
          vv = [line.slice(3).trim()[1],"1"];
        }
        bintxt += "8" + vv[0] + vv[1] + "6" + "\n";
      } else if (line.slice(0,5) == "SUBN ") {
        vv = get_vx_comma_vy ( line.slice(4).trim() );
        bintxt += "8" + vv[0] + vv[1] + "7" + "\n";
      } else if (line.slice(0,4) == "SHL ") {
        if (line.indexOf(",") >= 0) {
          // SHL Vx,Vy
          vv = get_vx_comma_vy ( line.slice(3).trim() );
          if (vv[0].length <= 0) {
            vv[0] = "?";
          }
        } else {
          // SHL Vx
          vv = [line.slice(3).trim()[1],"1"];
        }
        bintxt += "8" + vv[0] + vv[1] + "E" + "\n";
      } else if (line.slice(0,4) == "RND ") {
        vb = get_vx_comma_b ( line.slice(3) );
        bintxt += "C" + vb[0] + vb[1] + "\n";
      } else if (line.slice(0,4) == "DRW ") {
        pars = line.slice(3).split(",");
        pars[0] = pars[0].trim();
        pars[1] = pars[1].trim();
        pars[2] = pars[2].trim();
        bintxt += "D" + pars[0][1] + pars[1][1] + pars[2][0] + "\n";
      } else if (line.slice(0,4) == "SKP ") {
        vx = line.slice(3).trim();
        bintxt += "E" + vx[1] + "9E" + "\n";
      } else if (line.slice(0,5) == "SKNP ") {
        vx = line.slice(4).trim();
        bintxt += "E" + vx[1] + "A1" + "\n";
      } else {
        bintxt += "[??]" + line + "\n";
      }
    }
  }
  return ( bintxt );
}

function assemble() {
  // console.log ("Assemble source code window to machine code window");
  srctxt = document.getElementById ( "source" ).value;
  document.getElementById ( "machine" ).value = assemble_text ( srctxt );
}

function get_machine_lines ( text_in ) {
  // Normalize line endings and remove empty lines
  text = replaceAll( text_in, "\r", "\n");
  while (text.indexOf("\n\n") >= 0) {
    text = replaceAll(text, "\n\n", "\n");
  }
  // Convert to upper case
  text = "" + text.toUpperCase();
  // Remove all line endings
  while (text.indexOf("\n") >= 0) {
    text = replaceAll(text, "\n", "");
  }
  // Remove all spaces
  while (text.indexOf(" ") >= 0) {
    text = replaceAll(text, " ", "");
  }
  // Split by 4 digits per instruction
  lines = [];
  while (text.length > 0) {
    lines.push ( text.slice(0,4) );
    text = text.slice(4)
  }
  return ( lines );
}

function disassemble_line ( line ) {

  result = "";

  // #### : 00E0 00EE
  if (line == "00E0") {
    result += "CLS";
  } else if (line == "00EE") {
    result += "RET";

  // #nnn : 0 1 2 A B
  } else if (line[0] == "0") {
    result += "SYS " + line.slice(1);
  } else if (line[0] == "1") {
    // result += "JP L" + line.slice(1);
    result += "JP " + line.slice(1);
  } else if (line[0] == "2") {
    // result += "CALL L" + line.slice(1);
    result += "CALL " + line.slice(1);
  } else if (line[0] == "A") {
    result += "LD I," + line.slice(1);
  } else if (line[0] == "B") {
    result += "JP V0," + line.slice(1);

  // #nkk or #xkk : 3 4 6 7 C
  } else if (line[0] == "3") {
    result += "SE V" + line[1] + "," + line.slice(2);
  } else if (line[0] == "4") {
    result += "SNE V" + line[1] + "," + line.slice(2);
  } else if (line[0] == "6") {
    result += "LD V" + line[1] + "," + line.slice(2);
  } else if (line[0] == "7") {
    result += "ADD V" + line[1] + "," + line.slice(2);
  } else if (line[0] == "C") {
    result += "RND V" + line[1] + "," + line.slice(2);

  // #xy# : 5, 8, 9, D
  } else if (line[0] == "5") {
    if (line[3] == "0") {
      result += "SE V" + line[1] + ",V" + line[2];
    } else {
      result += "DATA " + line;
    }
  } else if (line[0] == "8") {
    if (line[3] == "0") {
      result += "LD V" + line[1] + ",V" + line[2];
    } else if (line[3] == "1") {
      result += "OR V" + line[1] + ",V" + line[2];
    } else if (line[3] == "2") {
      result += "AND V" + line[1] + ",V" + line[2];
    } else if (line[3] == "3") {
      result += "XOR V" + line[1] + ",V" + line[2];
    } else if (line[3] == "4") {
      result += "ADD V" + line[1] + ",V" + line[2];
    } else if (line[3] == "5") {
      result += "SUB V" + line[1] + ",V" + line[2];
    } else if (line[3] == "6") {
      result += "SHR V" + line[1] + ",V" + line[2];
    } else if (line[3] == "7") {
      result += "SUBN V" + line[1] + ",V" + line[2];
    } else if (line[3] == "E") {
      result += "SHL V" + line[1] + ",V" + line[2];
    } else {
      result += "DATA " + line;
    }
  } else if (line[0] == "9") {
    if (line[3] == "0") {
      result += "SNE V" + line[1] + ",V" + line[2];
    } else {
      result += "DATA " + line;
    }
  } else if (line[0] == "D") {
    result += "DRW V" + line[1] + ",V" + line[2] + "," + line[3];

  // #x## : E, F
  } else if (line[0] == "E") {
    if (line.slice(2) == "9E") {
      result += "SKP V" + line[1];
    } else if (line.slice(2) == "A1") {
      result += "SKNP V" + line[1];
    } else {
      result += "DATA " + line;
    }
  } else if (line[0] == "F") {
    if (line.slice(2) == "07") {
      result += "LD V" + line[1] + ",DT";
    } else if (line.slice(2) == "0A") {
      result += "LD V" + line[1] + ",K";
    } else if (line.slice(2) == "15") {
      result += "LD DT,V" + line[1];
    } else if (line.slice(2) == "18") {
      result += "LD ST,V" + line[1];
    } else if (line.slice(2) == "1E") {
      result += "ADD I,V" + line[1];
    } else if (line.slice(2) == "29") {
      result += "LD F,V" + line[1];
    } else if (line.slice(2) == "33") {
      result += "LD B,V" + line[1];
    } else if (line.slice(2) == "55") {
      result += "LD [I],V" + line[1];
    } else if (line.slice(2) == "65") {
      result += "LD V" + line[1] + ",[I]";
    } else {
      result += "DATA " + line;
    }

  // Unknown
  } else {
    result += "DATA " + line;
  }

  return ( result );
}


function disassemble() {
  // console.log ("Disassemble code");
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines
  lines = get_machine_lines ( bintxt );
  // console.log ( "Text = " + bintxt );
  opts = document.getElementById ( "disassem_opts" ).value;
  // console.log ( "Disassemble with options: " + opts );
  // Clear the source window
  document.getElementById ( "source" ).value = "";
  // Process the lines one by one
  for (l=0; l<lines.length; l++) {
    if ( (opts == "Std") || (opts.indexOf("L") >= 0) ) {
      // document.getElementById ( "source" ).value += "L"+((l*2)+0x200).toString(16).toUpperCase() + ": ";
      document.getElementById ( "source" ).value += ((l*2)+0x200).toString(16).toUpperCase() + ": ";
    }
    if (opts.indexOf("H") >= 0) {
      document.getElementById ( "source" ).value += lines[l] + "  ";
    }
    document.getElementById ( "source" ).value += disassemble_line ( lines[l] ) + "\n";
  }
  if (opts == "Std") {
    // Generate a "Standard" disassembly
    // Build a dictionary of all labels (should be one per line at this point)
    lines = document.getElementById ( "source" ).value.split("\n");
    all_labels = {};
    for (l=0; l<lines.length; l++) {
      if (lines[l].trim().length > 0) {
        if (lines[l].trim().indexOf(":") >= 0) {
          all_labels[lines[l].split(":")[0].trim()] = 0;
        }
      }
    }
    // Build a dictionary of all labels that have actually been used
    used_labels = {};
    for (l=0; l<lines.length; l++) {
      if (lines[l].trim().length > 0) {
        if (lines[l].trim().indexOf(":") >= 0) {
          src = lines[l].split(":")[1].trim();
          src = src.replaceAll(","," ");
          while (src.indexOf("  ") >= 0) {
            src = src.replaceAll("  ", " ");
          }
          src_parts = src.split(" ");
          for (p=0; p<src_parts.length; p++) {
            part = src_parts[p].trim();
            if (part in all_labels) {
              used_labels[part] = 1;
            }
          }
        }
      }
    }
    // Regenerate the source text with only those labels that have been used
    text = "";
    for (l=0; l<lines.length; l++) {
      this_line = lines[l].trim();
      if (this_line.length > 0) {
        sep = this_line.indexOf(":")
        if (sep < 0) {
          text += lines[l] + "\n";
        } else {
          lbl = this_line.substr(0,sep).trim();
          src = this_line.substr(sep+1).trim();
          if (lbl.trim() in used_labels) {
            text += lbl + ": " + src + "\n";
          } else {
            lsp = "";
            for (s=0; s<lbl.length; s++) lsp += " ";
            text += lsp + "  " + src + "\n";
          }
        }
      }
    }
    document.getElementById ( "source" ).value = text;
  }
}

saved_text = "";
function save() {
  saved_text = document.getElementById ( "source" ).value;
}

function restore() {
  document.getElementById ( "source" ).value = saved_text;
}

function load() {
  // Load from the machine code text area into mem
  stop_running = true;
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines of instructions
  lines = get_machine_lines ( bintxt );
  addr = 0x0200;
  for (i=0; i<lines.length; i++) {
    mem[addr++] = parseInt ( lines[i].slice(0,2), 16 );
    mem[addr++] = parseInt ( lines[i].slice(2,4), 16 );
  }
  update_display();
}

function reset() {
  stop_running = true;
  PC = 0x0200;
  SP = 0x0001;
  I  = 0x0000;
  N = 0;
  for (i=0; i<16; i++) {
    V[i] = 0;
  }
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      screen[r][c] = 0;
    }
  }
  draw_screen();
  update_display();
}

max_alerts = 3;
num_alerts = 0;
function limited_alert ( s ) {
  console.log ( s );
  if (num_alerts < max_alerts) {
    window.alert ( s );
    if (num_alerts == (max_alerts-1)) {
      window.alert ( "No more alerts will be issued. See console for more messages." );
    }
    num_alerts += 1;
  }
}

function step1() {
  // Could not use the name "step" for some reason?
  // document.getElementById("log").value += hex4(PC) + "> " + hex2(mem[PC]) + hex2(mem[PC+1]) + "\n";
  log_entry();
  instruction = (mem[PC] << 8) + mem[PC+1];
  // console.log ( "Execute " + hex4(instruction) );
  if (instruction == 0x00E0) { // CLS
    // console.log ( "CLS" );
    clear_screen();
    PC = PC + 2;
  } else if (instruction == 0x00EE) { // RET
    // console.log ( "RET" );
    // Cowgod: The interpreter sets the program counter to the address
    //         at the top of the stack, then subtracts 1 from the stack pointer.
    PC = (mem[SP-1] << 8) | mem[SP];
    PC = PC + 2;
    SP = SP - 2;
  } else if ( (instruction & 0xF000) == 0x0000) {  // SYS NNN
    // console.log ( "SYS" );
    limited_alert ( "The SYS instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x1000) {  // JP NNN
    // console.log ( "JP" );
    PC = instruction & 0xFFF;
  } else if ( (instruction & 0xF000) == 0x2000) { // CALL NNN
    // console.log ( "CALL" );
    // Cowgod: The interpreter increments the stack pointer,
    //         then puts the current PC on the top of the stack.
    //         The PC is then set to nnn.

    // Push the high byte onto the stack
    SP = SP + 1;
    mem[SP] = (PC >> 8) & 0x00FF;
    // Push the low byte onto the stack
    SP = SP + 1;
    mem[SP] = PC & 0x00FF;
    // Jump to the new location
    PC = instruction & 0xFFF;
  } else if ( (instruction & 0xF000) == 0x3000) { // SE Vx,byte
    // console.log ( "SE Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    if ( V[(instruction&0x0F00)>>8] == (instruction&0x00FF) ) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF000) == 0x4000) { // SNE Vx,byte
    // console.log ( "SNE - Skip if Not Equal immediate" );
    if ( V[(instruction&0x0F00)>>8] != (instruction&0x00FF) ) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF000) == 0x5000) { // SE Vx,Vy
    // console.log ( "SE - Skip if Equal Reg" );
    if ( V[(instruction&0x0F00)>>8] == V[(instruction&0x00F0)>>4]  ) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF000) == 0x6000) { // LD Vx,byte
    // console.log ( "LD immediate with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = instruction&0x00FF;
    PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x7000) { // ADD Vx,byte
    // console.log ( "ADD immediate === Add Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    x = (instruction&0x0F00)>>8;
    V[x] = (V[x] + (instruction&0x00FF)) & 0xFF;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8000) { // LD Vx,Vy
    // console.log ( "LD Vx,Vy" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x00F0)>>4];
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8001) { // OR Vx,Vy
    // console.log ( "OR Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] | V[(instruction&0x00F0)>>4];
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8002) { // AND Vx,Vy
    // console.log ( "AND Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] & V[(instruction&0x00F0)>>4];
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8003) { // XOR Vx,Vy
    // console.log ( "XOR Reg" );
    V[(instruction&0x0F00)>>8] = V[(instruction&0x0F00)>>8] ^ V[(instruction&0x00F0)>>4];
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8004) { // ADD Vx,Vy
    // console.log ( "ADD Reg" );
    result = V[(instruction&0x0F00)>>8] + V[(instruction&0x00F0)>>4];
    if (result > 0xFF) {
      V[0xF] = 1;
    } else {
      V[0xF] = 0;
    }
    V[(instruction&0x0F00)>>8] = result & 0xFF;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8005) { // SUB Vx,Vy: Vx = Vx - Vy
    // console.log ( "SUB Reg" );
    result = V[(instruction&0x0F00)>>8] - V[(instruction&0x00F0)>>4];
    if (result < 0) {
      V[0xF] = 0;
    } else {
      V[0xF] = 1;
    }
    V[(instruction&0x0F00)>>8] = result & 0xFF;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8006) { // SHR Vx,Vy: Vx = Vy >> 1
    // console.log ( "SHR" );
    V[0xF] = V[(instruction&0x00F0)>>4] & 0x01;
    V[(instruction&0x0F00)>>8] = V[(instruction&0x00F0)>>4] >> 1;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8007) { // SUBN Vx,Vy: Vx = Vy - Vx
    // console.log ( "SUBN" );
    result = V[(instruction&0x00F0)>>4] - V[(instruction&0x0F00)>>8];
    if (result < 0) {
      V[0xF] = 0;
    } else {
      V[0xF] = 1;
    }
    V[(instruction&0x0F00)>>8] = result & 0xFF;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x800E) { // SHL Vx,Vy
    // console.log ( "SHL" );
    V[0xF] = (V[(instruction&0x00F0)>>4] >> 7) & 0x01;
    V[(instruction&0x0F00)>>8] = (V[(instruction&0x00F0)>>4] << 1) & 0xff;
    PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x9000) { // SNE Vx,Vy
    // console.log ( "SNE - Skip if Not Equal Reg" );
    if ( V[(instruction&0x0F00)>>8] != V[(instruction&0x00F0)>>4] ) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF000) == 0xA000) { // I = NNN
    // console.log ( "LD I, addr" );
    I = instruction & 0xFFF;
    PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xB000) { // JP V0,NNN
    // console.log ( "JP V0, addr" );
    PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xC000) { // RND Vx,byte
    // console.log ( "RND Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = Math.floor(Math.random() * 256) & (instruction&0x00FF);
    PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xD000) { // DRW Vx,Vy,n
    // Draw a sprite at Vx,Vy of size nx8 from bytes at [I]
    vx = ( instruction & 0x0F00 ) >> 8;
    vy = ( instruction & 0x00F0 ) >> 4;
    n = instruction & 0x000F;
    pix_unset = false;
    for (pixrow=0; pixrow<n; pixrow++) {
      for (c=0; c<8; c++) {
        // Plain drawing (draw 1 in each location)
        //if ( mem[I+pixrow] & (0x80 >> c) ) {
        //  screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] = 1;
        //}
        // XOR drawing (perform XOR of each pix with memory)
        if ( mem[I+pixrow] & (0x80 >> c) ) {
          bit = 1;
        } else {
          bit = 0;
        }
        pix = screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols];
        new_pix = ( bit ^ pix );
        screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] = new_pix;
        // From Mikolay:
        //   Set VF to 01 if any set pixels are changed to unset, and 00 otherwise
        //   If a pixel on the screen is set to 01,
        //   and the sprite to be drawn contains a 01 for this same pixel,
        //   the screen pixel is turned off and VF is set to 01.
        //   If the sprite is simply drawn on the screen
        //   without drawing over any pixels set to 01, VF is set to 00.
        // From Winter:
        //   When one or more pixels are erased while a sprite is drawn,
        //   the VF register is set to 01, otherwise 00.
        if ((pix !=0) && (new_pix == 0)) {
          pix_unset = true;
        }
      }
    }
    if (pix_unset) {
      V[0xF] = 1;
    } else {
      V[0xF] = 0;
    }
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xE09E) { // SKP Vx (Skip if Key Vx is Pressed)
    // console.log ( "SKP Vx (Skip Key Vx is Pressed)" );
    // limited_alert ( "The SKP Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    // console.log ( "The SKP Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not fully implemented" );
    x = (instruction&0x0F00)>>8;
    if (keydown[x]!=0) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF0FF) == 0xE0A1) { // SKNP Vx (Skip if Key Vx is Not Pressed)
    // console.log ( "SKNP Vx" );
    // limited_alert ( "The SKNP Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    // console.log ( "The SKNP Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not fully implemented" );
    // Always skip for now
    x = (instruction&0x0F00)>>8;
    if (keydown[x]==0) {
      PC = PC + 4;
    } else {
      PC = PC + 2;
    }
  } else if ( (instruction & 0xF0FF) == 0xF007) { // LD Vx, DT  (Set Vx to current Delay Timer value)
    // console.log ( "LD Vx,DT" );
    V[(instruction&0x0F00)>>8] = T;
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF00A) { // LD Vx, K
    // console.log ( "LD Vx,K" );
    // k = wait_for_key();
    limited_alert ( "The LD Vx,K instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    console.log ( "The LD Vx,K instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF015) { // LD DT, Vx  (Set Delay Timer value to Vx)
    // console.log ( "LD DT,Vx" );
    T = V[(instruction&0x0F00)>>8];
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF018) { // LD ST, Vx
    // console.log ( "LD ST,Vx" );
    // limited_alert ( "The LD ST,Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    beep();
    // console.log ( "The LD ST,Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF01E) { // ADD I, Vx
    // console.log ( "ADD I, Vx" );
    I = I + V[(instruction&0x0F00)>>8];
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF029) { // LD F, Vx
    // console.log ( "LD F,Vx" );
    // It's not clear if the "Vx" should represent:
    //   (a) the 4-bit number corresponding to the digit to be drawn
    // digit = (instruction&0x0F00)>>8;
    //   (b) the 4-bit register number holding the number of the digit
    digit = V[(instruction&0x0F00)>>8];
    I = font_addr + (5 * digit); // There are 5 rows per digit
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF033) { // LD B, Vx
    // console.log ( "LD B,Vx" );
    // From Matt Mikolay:
    //   Store the binary-coded decimal equivalent of the value stored in register VX at addresses I, I+1, and I+2
    // console.log ( "LD B,Vx is (" + hex4(instruction) + ") at " + hex4(PC) + "" );
    x = V[(instruction&0x0F00) >> 8];
    x2 = Math.floor(x/100);
    x1 = Math.floor((x-(100*x2))/10);
    x0 = x % 10;
    console.log ( "LD B,Vx with x=" + x + ": " + x2 + " " + x1 + " " + x0 );
    mem[I++] = x2;
    mem[I++] = x1;
    mem[I++] = x0;
    // limited_alert ( "The LD B,Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    // console.log ( "The LD B,Vx instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF055) { // LD [I], Vx
    // console.log ( "LD [I],Vx" );
    // From Matt Mikolay:
    //   Store the values of registers V0 to VX inclusive in memory starting at address I
    //   I is set to I + X + 1 after operation
    x = (instruction&0x0F00) >> 8;
    for (i=0; i<=x; i++) {
      mem[I] = V[i];
      I += 1;
    }
    // limited_alert ( "The LD [I],Vx instruction (" + instruction + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF065) { // LD Vx, [I]
    // console.log ( "LD Vx,[I]" );
    // From Matt Mikolay:
    //   Fill registers V0 to VX inclusive with the values stored in memory starting at address I
    //   I is set to I + X + 1 after operation
    x = (instruction&0x0F00) >> 8;
    for (i=0; i<=x; i++) {
      V[i] = mem[I];
      I += 1;
    }
    // limited_alert ( "The LD Vx,[I] instruction (" + instruction + ") at " + hex4(PC) + " is not implemented" );
    PC = PC + 2;
  } else {
    // console.log ( "UNKNOWN INSTRUCTION: " + hex4(instruction) );
    limited_alert ( "This instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not recognized" );
    console.log ( "This instruction (" + hex4(instruction) + ") at " + hex4(PC) + " is not recognized" );
    PC = PC + 2;
  }
  N = N + 1;
  update_display();
  draw_screen();
}

var pause_time_ms = 100; // 100
var running = false;
var stop_running = false;

function run1() {
  stop_running = true;
  if (!running) {
    for (stepnum=0; stepnum<ST; stepnum++) {
      step1();
    }
  } else {
    stop_running = true;
  }
}

timer_60Hz = null;
timer_run = null;

function timer() {
  // console.log ( "Timer tick" );
  if (T > 0) {
    T = T - 1;
  }
}

function run() {
  // console.log ( "Top of run" );
  if (stop_running == false) {
    // console.log ( "  stop_running is false" );
    for (stepnum=0; stepnum<ST; stepnum++) {
      // console.log ( "    run one step" );
      if (stop_running) {
        running = false;
        update_rs_button();
        return ( false );
      }
      step1();
    }
    // console.log ( "  reset the timeout" );
    if (timer_run != null) {
      clearTimeout ( timer_run );
    }
    timer_run = setTimeout ( "run()", CT ); // pause_time_ms );
    if (timer_60Hz == null) {
      timer_60Hz = setInterval ( "timer()", DT );     // 60Hz = 17 = 1000 * 0.0166666666667
    }
  } else {
    // console.log ( "  stop_running is true" );
    running = false;
    update_rs_button();
    if (timer_run != null) {
      clearTimeout ( timer_run );
      timer_run = null;
    }
    if (timer_60Hz != null) {
      // console.log ( "    clearing timer_60Hz" );
      clearInterval ( timer_60Hz );
      timer_60Hz = null;
    }
  }
  return ( false );
}

function stop() {
}

function update_variables() {
  ST = parseInt ( document.getElementById("ST").value );
  CT = parseInt ( document.getElementById("CT").value );
  DT = parseInt ( document.getElementById("DT").value );
}

function key_press ( k ) {
  console.log ( "Key " + k + " pressed" );
}

function on_doc_change() {
  // console.log ( "on_doc_change called" );
  let selector = document.getElementById("show_help");
  let setting = selector[selector.selectedIndex].value;
  let n = selector.options.length;
  for (let i=0; i<n; i++) {
    let ith_id = selector.options[i].value;
    if (ith_id == setting) {
      document.getElementById(ith_id).hidden = false;
    } else {
      document.getElementById(ith_id).hidden = true;
    }
  }
}

function on_example_change() {
  let selector = document.getElementById("example_select");
  let setting = selector[selector.selectedIndex].value;
  if (setting.startsWith("Hex:")) {
    document.getElementById ( "machine" ).value = document.getElementById(setting.substr(4)).innerHTML;
    document.getElementById ( "source" ).value = "";
  } else {
    document.getElementById ( "source" ).value = document.getElementById(setting).innerHTML;
  }
  if ("name" in document.getElementById(setting).attributes) {
    // Use the name for the key mapping data
    namedata = document.getElementById(setting).attributes['name'].value;
    console.log ( "Name data = " + namedata );
    eval("key_remap="+namedata);
    console.log ( "key_remap evaluated to: " );
    console.log ( key_remap );
  }
}

function update_rs_button() {
  if (running) {
    document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
    document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
  } else {
    document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
    document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
  }
}

function run_stop_clicked() {
  if (! assem_loaded_once) {
    // Automatically assemble and load the first time
    reload_and_wait();
    assem_loaded_once = true;
  }

  running = !running;
  if (running) {
    stop_running = false;
    //document.getElementById('RunStop').innerHTML = "<u>Run</u>/Stop";
    //document.getElementById('RunStop').setAttribute("style", "background-color: #FF9999;");
    run();
  } else {
    stop_running = true;
    //document.getElementById('RunStop').innerHTML = "Run/<u>Stop</u>";
    //document.getElementById('RunStop').setAttribute("style", "background-color: #99FF99;");
  }
  update_rs_button();
}

function step_clicked() {
  beep();
  run1();
}

function reload_and_wait() {
  stop_running = true;
  running = false;
  reset();
  assemble();
  load();
  update_rs_button();
  reset();
}

function reload_and_run() {
  reload_and_wait();
  run_stop_clicked();
}


// From: https://stackoverflow.com/questions/879152/how-do-i-make-javascript-beep

var snd = new Audio("data:audio/wav;base64,//uQRAAAAWMSLwUIYAAsYkXgoQwAEaYLWfkWg" +
                    "AI0wWs/ItAAAGDgYtAgAyN+QWaAAihwMWm4G8QQRDiMcCBcH3Cc+CDv/7xA" +
                    "4Tvh9Rz/y8QADBwMWgQAZG/ILNAARQ4GLTcDeIIIhxGOBAuD7hOfBB3/94g" +
                    "cJ3w+o5/5eIAIAAAVwWgQAVQ2ORaIQwEMAJiDg95G4nQL7mQVWI6GwRcfsZ" +
                    "AcsKkJvxgxEjzFUgfHoSQ9Qq7KNwqHwuB13MA4a1q/DmBrHgPcmjiGoh//E" +
                    "wC5nGPEmS4RcfkVKOhJf+WOgoxJclFz3kgn//dBA+ya1GhurNn8zb//9NNu" +
                    "tNuhz31f////9vt///z+IdAEAAAK4LQIAKobHItEIYCGAExBwe8jcToF9zI" +
                    "KrEdDYIuP2MgOWFSE34wYiR5iqQPj0JIeoVdlG4VD4XA67mAcNa1fhzA1jw" +
                    "HuTRxDUQ//iYBczjHiTJcIuPyKlHQkv/LHQUYkuSi57yQT//uggfZNajQ3V" +
                    "mz+Zt//+mm3Wm3Q576v////+32///5/EOgAAADVghQAAAAA//uQZAUAB1WI" +
                    "0PZugAAAAAoQwAAAEk3nRd2qAAAAACiDgAAAAAAABCqEEQRLCgwpBGMlJkI" +
                    "z8jKhGvj4k6jzRnqasNKIeoh5gI7BJaC1A1AoNBjJgbyApVS4IDlZgDU5WU" +
                    "AxEKDNmmALHzZp0Fkz1FMTmGFl1FMEyodIavcCAUHDWrKAIA4aa2oCgILEB" +
                    "upZgHvAhEBcZ6joQBxS76AgccrFlczBvKLC0QI2cBoCFvfTDAo7eoOQInqD" +
                    "PBtvrDEZBNYN5xwNwxQRfw8ZQ5wQVLvO8OYU+mHvFLlDh05Mdg7BT6YrRPp" +
                    "CBznMB2r//xKJjyyOh+cImr2/4doscwD6neZjuZR4AgAABYAAAABy1xcdQt" +
                    "xYBYYZdifkUDgzzXaXn98Z0oi9ILU5mBjFANmRwlVJ3/6jYDAmxaiDG3/6x" +
                    "jQQCCKkRb/6kg/wW+kSJ5//rLobkLSiKmqP/0ikJuDaSaSf/6JiLYLEYnW/" +
                    "+kXg1WRVJL/9EmQ1YZIsv/6Qzwy5qk7/+tEU0nkls3/zIUMPKNX/6yZLf+k" +
                    "FgAfgGyLFAUwY//uQZAUABcd5UiNPVXAAAApAAAAAE0VZQKw9ISAAACgAAA" +
                    "AAVQIygIElVrFkBS+Jhi+EAuu+lKAkYUEIsmEAEoMeDmCETMvfSHTGkF5RW" +
                    "H7kz/ESHWPAq/kcCRhqBtMdokPdM7vil7RG98A2sc7zO6ZvTdM7pmOUAZTn" +
                    "JW+NXxqmd41dqJ6mLTXxrPpnV8avaIf5SvL7pndPvPpndJR9Kuu8fePvuiu" +
                    "horgWjp7Mf/PRjxcFCPDkW31srioCExivv9lcwKEaHsf/7ow2Fl1T/9RkXg" +
                    "EhYElAoCLFtMArxwivDJJ+bR1HTKJdlEoTELCIqgEwVGSQ+hIm0NbK8WXcT" +
                    "EI0UPoa2NbG4y2K00JEWbZavJXkYaqo9CRHS55FcZTjKEk3NKoCYUnSQ0rW" +
                    "xrZbFKbKIhOKPZe1cJKzZSaQrIyULHDZmV5K4xySsDRKWOruanGtjLJXFEm" +
                    "waIbDLX0hIPBUQPVFVkQkDoUNfSoDgQGKPekoxeGzA4DUvnn4bxzcZrtJyi" +
                    "pKfPNy5w+9lnXwgqsiyHNeSVpemw4bWb9psYeq//uQZBoABQt4yMVxYAIAA" +
                    "AkQoAAAHvYpL5m6AAgAACXDAAAAD59jblTirQe9upFsmZbpMudy7Lz1X1DY" +
                    "sxOOSWpfPqNX2WqktK0DMvuGwlbNj44TleLPQ+Gsfb+GOWOKJoIrWb3cIMe" +
                    "eON6lz2umTqMXV8Mj30yWPpjoSa9ujK8SyeJP5y5mOW1D6hvLepeveEAEDo" +
                    "0mgCRClOEgANv3B9a6fikgUSu/DmAMATrGx7nng5p5iimPNZsfQLYB2sDLI" +
                    "kzRKZOHGAaUyDcpFBSLG9MCQALgAIgQs2YunOszLSAyQYPVC2YdGGeHD2dT" +
                    "dJk1pAHGAWDjnkcLKFymS3RQZTInzySoBwMG0QueC3gMsCEYxUqlrcxK6k1" +
                    "LQQcsmyYeQPdC2YfuGPASCBkcVMQQqpVJshui1tkXQJQV0OXGAZMXSOEEBR" +
                    "irXbVRQW7ugq7IM7rPWSZyDlM3IuNEkxzCOJ0ny2ThNkyRai1b6ev//3dzN" +
                    "GzNb//4uAvHT5sURcZCFcuKLhOFs8mLAAEAt4UWAAIABAAAAAB4qbHo0tIj" +
                    "VkUU//uQZAwABfSFz3ZqQAAAAAngwAAAE1HjMp2qAAAAACZDgAAAD5UkTE1" +
                    "UgZEUExqYynN1qZvqIOREEFmBcJQkwdxiFtw0qEOkGYfRDifBui9MQg4QAH" +
                    "AqWtAWHoCxu1Yf4VfWLPIM2mHDFsbQEVGwyqQoQcwnfHeIkNt9YnkiaS1oi" +
                    "zycqJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18" +
                    "eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXM" +
                    "lmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgD" +
                    "GCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm" +
                    "+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/" +
                    "r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgb" +
                    "bJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5" +
                    "F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEE" +
                    "ECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00" +
                    "y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/X" +
                    "x4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS" +
                    "+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+L" +
                    "khyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1" +
                    "+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///q" +
                    "poiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0" +
                    "WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQR" +
                    "CSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRob" +
                    "BAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4F" +
                    "FRQWR+LsS4W/rFRb///////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "///////////////////////////////////////////////////////////" +
                    "////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                    "AAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" +
                    "AAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZ" +
                    "GUAAAAAAAAAACU=");

function beep() {
  snd.play();
}

</script>

<body bgcolor="lightblue" onload="onload()">
<center>

<span id="title"><b>CHIP-8 Development Environment</b></span>
<p/>
<center>
<table>
  <tr>
    <!--
    <td>
      <select id="assem_opts" onchange="changed_format()">
      <option value="H" selected>Plain Hex</option>
      <option value="I">Intel Hex</option>
      </select>
    </td>
    -->
    <td>
      <input type="button" name="assem" value="Assemble" onclick="beep(); assemble();"></input>
    </td>
    <td>
      <input type="button" name="save" value="Save" onclick="beep(); save();"></input>
    </td>
    <td>
      <input type="button" name="restore" value="Restore" onclick="beep(); restore();"></input>
    </td>
    <td>
      &nbsp; &nbsp; &nbsp; &nbsp;
      <input type="button" name="disassem" value="Disassemble as" onclick="beep(); disassemble();"></input>
    </td>
    <td>
      <select id="disassem_opts" onchange="changed_format()">
      <option value="S">Src</option>
      <option value="LS">L+S</option> -->
      <option value="Std" selected>Std</option> -->
      <option value="HS">H+S</option> -->
      <option value="LHS">LHS</option> -->
      </select>
    </td>
    <td>
      &nbsp; &nbsp; &nbsp; &nbsp;
      <input type="button" name="load"  value="Load"  onclick="beep(); load();"></input>
      <input type="button" name="reset"  value="Reset"  onclick="beep(); reset();"></input>
    </td>
    <td>
      &nbsp; &nbsp; &nbsp; &nbsp;
      <input type="button" name="run1" value="Step" onclick="step_clicked();"></input>
      &nbsp; &nbsp;
      <input type="button" name="stop" value="" onclick="beep(); reload_and_wait();" style="background-color: #AAAAFF;"></input>
      &nbsp; &nbsp;
      <button type="button" id="RunStop" onclick="run_stop_clicked(); beep();" style="background-color: #99FF99;">Run/<u>Stop</u></button>

    </td>
  </tr>
</table>
<center>
<table width="100%" style="padding:10px; border-spacing:2px; border:4px solid black; background-color:#dddddd; text-align:left; font-family: Arial, Helvetica, sans-serif; font-size: 14px;" >
  <colgroup>
    <col>
    <col>
  </colgroup>
  <thead>
    <tr>
      <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Source Code</th>
      <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Machine Code</th>
      <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Chip-8 Virtual Machine</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td valign="top">
        <center>
        <textarea id="source" rows="27" cols="64"
           autocomplete="off" autocorrect="off"
           autocapitalize="off" spellcheck="false"></textarea>
        </center>
      </td>

      <td valign="top">
        <center>

        <textarea id="machine" rows="27" cols="6"
           autocomplete="off" autocorrect="off"
           autocapitalize="off" spellcheck="false"></textarea>
        </center>
      </td>

      <td valign="top"> <!-- Start of VIRTUAL MACHINE -->
        <center>
        <table>
        <tr><td>
        <center>
          <!--div id="tdiv" style="resize: both; overflow: auto;"--> 
          <div id="tdiv">
          <center>
          <canvas id="drawing_area" width="320" height="160"
            style="margin:2px; padding:2px; border:2px solid #cccccc; resize: both; overflow: auto;"> 
            <!-- Use: style="margin:2px; padding:2px; border:2px solid #cccccc; display:none;" -->
            Your browser does not support the HTML5 canvas tag.
          </canvas>
          </center>
          </div>
        </center>
        </td></tr>
        <tr><td>
        <center>
        <table> <!-- Start of Virtual Machine Controls -->
          <tr>
          <!-- Memory Controls -->
          <td>
          <center>
            <input type="button" name="memup"  value=""  onclick="beep(); mem_top = 0x0000; update_display();"></input></br>
            <input type="button" name="memup"  value=""  onclick="beep(); mem_top = Math.max(0,mem_top-1024); update_display();"></input></br>
            <input type="button" name="memup"  value=""  onclick="beep(); mem_top = Math.max(0,mem_top-16); update_display();"></input></br>
            <input type="button" name="memup"  value=""  onclick="beep(); mem_top = Math.max(0,mem_top-2); update_display();"></input></br>
            <input type="button" name="memup"  value=""  onclick="beep(); mem_top = 0x0200; update_display();"></input></br>
            <input type="button" name="memdn"  value=""  onclick="beep(); mem_top = Math.min(0xffe0,mem_top+2); update_display();"></input></br>
            <input type="button" name="memdn"  value=""  onclick="beep(); mem_top = Math.min(0xffe0,mem_top+16); update_display();"></input></br>
            <input type="button" name="memdn"  value=""  onclick="beep(); mem_top = Math.min(0xffe0,mem_top+1024); update_display();"></input></br>
            <input type="button" name="memdn"  value=""  onclick="beep(); mem_top = 0xffe0; update_display();"></input></br>
          </center>
          </td>
          <!-- Memory table -->
          <td style="vertical-align: top;">
            <table class="mem">
              <tr class="mem"><td class="mem" id="A0"></td><td class="mem"><input type="text" id="M0" class="mem" name="M0" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A1"></td><td class="mem"><input type="text" id="M1" class="mem" name="M1" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A2"></td><td class="mem"><input type="text" id="M2" class="mem" name="M2" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A3"></td><td class="mem"><input type="text" id="M3" class="mem" name="M3" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A4"></td><td class="mem"><input type="text" id="M4" class="mem" name="M4" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A5"></td><td class="mem"><input type="text" id="M5" class="mem" name="M5" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A6"></td><td class="mem"><input type="text" id="M6" class="mem" name="M6" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A7"></td><td class="mem"><input type="text" id="M7" class="mem" name="M7" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A8"></td><td class="mem"><input type="text" id="M8" class="mem" name="M8" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="A9"></td><td class="mem"><input type="text" id="M9" class="mem" name="M9" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AA"></td><td class="mem"><input type="text" id="MA" class="mem" name="MA" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AB"></td><td class="mem"><input type="text" id="MB" class="mem" name="MB" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AC"></td><td class="mem"><input type="text" id="MC" class="mem" name="MC" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AD"></td><td class="mem"><input type="text" id="MD" class="mem" name="MD" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AE"></td><td class="mem"><input type="text" id="ME" class="mem" name="ME" size="4"></td></tr>
              <tr class="mem"><td class="mem" id="AF"></td><td class="mem"><input type="text" id="MF" class="mem" name="MF" size="4"></td></tr>
            </table>
          </td>
          <!-- Register table -->
          <td style="vertical-align: top;">
            <table class="reg">
              <tr class="reg"><td class="reg">V0</td><td class="reg"><input type="text" id="V0" class="reg" name="V0" size="2"></td></tr>
              <tr class="reg"><td class="reg">V1</td><td class="reg"><input type="text" id="V1" class="reg" name="V1" size="2"></td></tr>
              <tr class="reg"><td class="reg">V2</td><td class="reg"><input type="text" id="V2" class="reg" name="V2" size="2"></td></tr>
              <tr class="reg"><td class="reg">V3</td><td class="reg"><input type="text" id="V3" class="reg" name="V3" size="2"></td></tr>
              <tr class="reg"><td class="reg">V4</td><td class="reg"><input type="text" id="V4" class="reg" name="V4" size="2"></td></tr>
              <tr class="reg"><td class="reg">V5</td><td class="reg"><input type="text" id="V5" class="reg" name="V5" size="2"></td></tr>
              <tr class="reg"><td class="reg">V6</td><td class="reg"><input type="text" id="V6" class="reg" name="V6" size="2"></td></tr>
              <tr class="reg"><td class="reg">V7</td><td class="reg"><input type="text" id="V7" class="reg" name="V7" size="2"></td></tr>
              <tr class="reg"><td class="reg">V8</td><td class="reg"><input type="text" id="V8" class="reg" name="V8" size="2"></td></tr>
              <tr class="reg"><td class="reg">V9</td><td class="reg"><input type="text" id="V9" class="reg" name="V9" size="2"></td></tr>
              <tr class="reg"><td class="reg">VA</td><td class="reg"><input type="text" id="VA" class="reg" name="VA" size="2"></td></tr>
              <tr class="reg"><td class="reg">VB</td><td class="reg"><input type="text" id="VB" class="reg" name="VB" size="2"></td></tr>
              <tr class="reg"><td class="reg">VC</td><td class="reg"><input type="text" id="VC" class="reg" name="VC" size="2"></td></tr>
              <tr class="reg"><td class="reg">VD</td><td class="reg"><input type="text" id="VD" class="reg" name="VD" size="2"></td></tr>
              <tr class="reg"><td class="reg">VE</td><td class="reg"><input type="text" id="VE" class="reg" name="VE" size="2"></td></tr>
              <tr class="reg"><td class="reg">VF</td><td class="reg"><input type="text" id="VF" class="reg" name="VF" size="2"></td></tr>
            </table>
          </td>
          <!-- PC and [I] table -->
          <td style="vertical-align: top;">
            <table>
              <tr>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">PC</td><td class="reg"><input type="text" id="PC" class="reg" name="PC" size="4"></td></tr>
                  </table>
                </td>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg"><input type="text" id="PCINST" class="regleft" name="PCINST" size="12"></td></tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">SP</td><td class="reg"><input type="text" id="SP" class="reg" name="SP" size="4"></td></tr>
                  </table>
                </td>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">&nbsp;N&nbsp;</td><td class="reg"><input type="text" id="N" class="reg" name="N" size="9" readonly></td></tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">[ I ]</td><td class="reg"><input type="text" id="[I]" class="reg" name="[I]" size="4"></td></tr>
                  </table>
                </td>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">ST</td><td class="reg"><input type="text" id="ST" class="reg" name="ST" size="9"></td></tr>
                  </table>
                </td>
              </tr>
              <tr>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">DT</td><td class="reg"><input type="text" id="DT" class="reg" name="DT" size="4"></td></tr>
                  </table>
                </td>
                <td>
                  <table class="reg">
                    <tr class="reg"><td class="reg">CT</td><td class="reg"><input type="text" id="CT" class="reg" name="CT" size="9"></td></tr>
                  </table>
                </td>
              </tr>
            </table>
            <center>
            <table>
              <tr><td>&nbsp;</td></tr>
              <tr><td><input type="button" value="0" onmousedown="bd(0,1);" onmouseup="bd(0,0);"></td>
                   <td><input type="button" value="1" onmousedown="bd(1,1);" onmouseup="bd(1,0);"></td>
                    <td><input type="button" value="2" onmousedown="bd(2,1);" onmouseup="bd(2,0);"></td>
                     <td><input type="button" value="3" onmousedown="bd(3,1);" onmouseup="bd(3,0);"></td> </tr>
              <tr><td><input type="button" value="4" onmousedown="bd(4,1);" onmouseup="bd(4,0);"></td>
                   <td><input type="button" value="5" onmousedown="bd(5,1);" onmouseup="bd(5,0);"></td>
                    <td><input type="button" value="6" onmousedown="bd(6,1);" onmouseup="bd(6,0);"></td>
                     <td><input type="button" value="7" onmousedown="bd(7,1);" onmouseup="bd(7,0);"></td> </tr>
              <tr><td><input type="button" value="8" onmousedown="bd(8,1);" onmouseup="bd(8,0);"></td>
                   <td><input type="button" value="9" onmousedown="bd(9,1);" onmouseup="bd(9,0);"></td>
                    <td><input type="button" value="A" onmousedown="bd(10,1);" onmouseup="bd(10,0);"></td>
                     <td><input type="button" value="B" onmousedown="bd(11,1);" onmouseup="bd(11,0);"></td> </tr>
              <tr><td><input type="button" value="C" onmousedown="bd(12,1);" onmouseup="bd(12,0);"></td>
                   <td><input type="button" value="D" onmousedown="bd(13,1);" onmouseup="bd(13,0);"></td>
                    <td><input type="button" value="E" onmousedown="bd(14,1);" onmouseup="bd(14,0);"></td>
                     <td><input type="button" value="F" onmousedown="bd(15,1);" onmouseup="bd(15,0);"></td> </tr>
            </table>
            </center>
          </td>
          </tr>
        </table> <!-- End of Virtual Machine Controls -->
        </center>
        </td></tr>
        </table>
        </center>
      </td>  <!-- End of VIRTUAL MACHINE -->

    </tr>
  </tbody>
</table>

<p/><hr/><p/>


<b>Examples:</b>
<select id="example_select" onchange="on_example_change()">
<option value="none" selected>-- Select --</option>
</select>
<!-- <button type="button" onclick="on_example_change();">Load</button> -->
<input type="button" name="run"  value="Run"  onclick="beep(); reload_and_run();"></input>

 &nbsp; &nbsp; &nbsp; <b>Documentation:</b>
<select id="show_help" onchange="on_doc_change()">
<option value="none" selected>-- Select --</option>
<option value="introduction" selected>Introduction</option>
<option value="instruction_set">Instruction Set</option>
<option value="hex_to_binary">Hex to Binary</option>
<option value="examples">Examples</option>
</select>
<button type="button" onclick="beep(); on_doc_change();">Show</button>


<p/><hr/><p id="plog"></p>


<!-- for some reason, there are at least 3 unmatched "center" tags above that should be closed! -->
</center>
</center>
</center>


<div id="none" hidden></div>


<div id="introduction" hidden>
<center><h3>Introduction</h3></center>

This Javascript/HTML program implements a virtual machine and development environment for the CHIP-8 programming language.
<br></br>
CHIP-8 source code can be entered in the <b>Source Code</b> text area. It can then be assembled into the
<b>Machine Code</b> text area. From there it can be loaded into the <b>CHIP-8 Virtual Machine</b> and run. The CHIP-8
graphics screen is the program's primary output device and it is 64 x 32 (or 40 x 20 in hex).
<br></br>
<center><h3>Quick Start</h3></center>
The <b>CHIP-8 Development Environment</b> will generally start with a program already in the <b>Source Code</b> text area.
But that program will need to be assembled and loaded into the <b>CHIP-8 Virtual Machine</b> first.
These steps (and a Reset) can all be accomplished by clicking the light blue reload button ("<b style="font-size:larger;"></b>")
near the upper right corner. The program can then be run by clicking the "<b>Run/Stop</b>" button (also in the upper
right corner). Different programs can be either copied or typed into the <b>Source Code</b> text area. Programs
can also be loaded from the built-in examples using the <b>Examples</b> selector described below.

<br></br>
<center><h3>Top row buttons: Assembling, Loading, Running</h3></center>


The "<b>Assemble</b>" button assembles the source code and produces machine code.
<br></br>
The "<b>Save</b>" button saves a copy of the source window internally (it may be lost if you leave the page).
<br></br>
The "<b>Restore</b>" button restores the internally saved copy of the source window.
<br></br>
The "<b>Diassemble as</b>" button will disassemble from the Machine Code window into the Source Code window
(over-writing any text already in the Source Code window). The format of the disassembly is governed
by the selector which is one of the following:
<ul>
<li><b>Src</b>: Generates only source - can be reassembled.</li>
<li><b>L+S</b>: Generates all labels and source - can be reassembled.</li>
<li><b>Std</b>: Generates needed labels and source - can be reassembled.</li>
<li><b>H+S</b>: Generates hex and source - cannot be reassembled.</li>
<li><b>LHS</b>: Generates all labels, hex, and source - cannot be reassembled.</li>
</ul>

The "<b>Load</b>" button will load the hex values in the "Machine Code" window into the memory of the simulation.
You will see the machine code in the memory area below the graphics window.
<br></br>

The "<b>Reset</b>" button clears the graphics output and set all registers to their default state.
<br></br>

The "<b>Step</b>" button will run a single CHIP-8 instruction and then stop.
<br></br>

The reload button ("<b style="font-size:larger;"></b>") button will assemble, load, and reset.
<br></br>

Finally the "<b>Run/Stop</b>" will toggle the clock between running and stopped.
<br></br>

<center><h3>Examples</h3></center>
The "Examples" control allows selecting from a number of example programs.
Selecting any of the examples from the selection menu will replace the
current code with that example. BE SURE YOUR CODE IS SAVED FIRST!! Once
an example is loaded, it can be easily run with the "Run" button.

<center><h3>Documentation</h3></center>
The "Documentation" control allows selecting from a number of topics.
If the topic doesn't show for some reaon, try clicking the "Show" button.
Among other things, the full CHIP-8 instruction set and all of the examples
are available via the Documentation and Examples controls.

<center><h3>Limitations</h3></center>
<ol>
<li>The assembler is very quirky. It uses simple string matching and can often
make mistakes. These will typically show up as extra or missing characters in
the assembled output (hex). Scroll up and down the hex to look for lines that
don't have exactly 4 hex characters per line. Do not use symbol names that
are substrings of other symbol names. The symbols "loopA" and "loop" will confuse
the assembler when it does string search and replace operations. But using
"loopA" and "loopB" are OK since neither is a substring of the other.
</li>
<li>Hex values should be entered with the proper number of digits
(1 for a nibble, 2 for a byte, 3 for a CHIP-8 address, and 4 for a full address).
Any other number of digits (too many or too few) will cause assembly problems.
</li>
<li>A few instructions haven't been implemented yet. Most have not been tested.
</li>
<li>There is only limited support for keyboard input and sound at this time.
</li>

<hr/>

</div>


<div id="instruction_set" hidden>

<p/>
<center>
=== Instruction Set and Assembler Syntax === <!-- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM -->
<table><tr><td>
<tt>
<pre>
Code   Assembly           Description - All numbers are hexadecimal
----   --------           -----------------------------------------
       lbl:               &#x2705; A label - must not match any other string in the program!
nnnn - DATA nnnn          &#x2705; Initialize a data word (all values in hex)

0nnn - SYS addr           &#x274C;? Jump to a machine code routine at nnn.
00E0 - CLS                &#x2705;? Clear the display.
00EE - RET                &#x2705;? Return from a subroutine.
1nnn - JP addr            &#x2705;? Jump to location nnn.
2nnn - CALL addr          &#x2705;? Call subroutine at nnn.
3xkk - SE Vx, byte        &#x2705;? Skip If Equal Immediate: Skip next instruction if Vx = kk.
4xkk - SNE Vx, byte       &#x2705;? Skip If Not Equal Immediate: Skip next instruction if Vx != kk.
5xy0 - SE Vx, Vy          &#x2705;? Skip If Equal Register: Skip next instruction if Vx = Vy.
6xkk - LD Vx, byte        &#x2705;? Load Immediate: Set Vx = kk.
7xkk - ADD Vx, byte       &#x2705;? Add Immediate: Set Vx = Vx + kk.
8xy0 - LD Vx, Vy          &#x2705;? Load Register: Set Vx = Vy.
8xy1 - OR Vx, Vy          &#x2705;? Or Register: Set Vx = Vx OR Vy.
8xy2 - AND Vx, Vy         &#x2705;? And Register: Set Vx = Vx AND Vy.
8xy3 - XOR Vx, Vy         &#x2705;? XOR Register: Set Vx = Vx XOR Vy.
8xy4 - ADD Vx, Vy         &#x2705;? Add Register: Set Vx = Vx + Vy, set VF = carry.
8xy5 - SUB Vx, Vy         &#x2705;? Sub Register: Set Vx = Vx - Vy, set VF = NOT borrow.
8xy6 - SHR Vx {, Vy}      &#x2705;? Shift Right: Set Vx = Vx SHR 1.
8xy7 - SUBN Vx, Vy        &#x2705;? Sub Negative Register: Set Vx = Vy - Vx, set VF = NOT borrow.
8xyE - SHL Vx {, Vy}      &#x2705;? Shift Left: Set Vx = Vx SHL 1.
9xy0 - SNE Vx, Vy         &#x2705;? Skip If Not Equal: Skip next instruction if Vx != Vy.
Annn - LD I, addr         &#x2705;? Load I Immediate: Set I = nnn.
Bnnn - JP V0, addr        &#x2705;? Jump to V0 with offset nnn.
Cxkk - RND Vx, byte       &#x2705;? Rand: Set Vx to a random number (0 to 255) AND byte value.
Dxyn - DRW Vx, Vy, n      &#x2705;? Draw: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
Ex9E - SKP Vx             &#x2705;? Skip if Key[Vx]: Skip next instruction if key with the value of Vx is pressed.
ExA1 - SKNP Vx            &#x2705;? Skip if !Key[Vx]: Skip next instruction if key with the value of Vx is not pressed.
Fx07 - LD Vx, DT          &#x2705;? Load Vx from Delay Timer: Set Vx = delay timer value.
Fx0A - LD Vx, K           &#x274C;? Load Vx from next Key: Wait for a key press, store the value of the key in Vx.
Fx15 - LD DT, Vx          &#x2705;? Load Delay Timer from Vx: Set delay timer = Vx.
Fx18 - LD ST, Vx          &#x2705;? Load Sound Timer from Vx: Set sound timer = Vx.
Fx1E - ADD I, Vx          &#x2705;? Add Vx to I: Set I = I + Vx.
Fx29 - LD F, Vx           &#x2705;? Load I from Sprite location: Set I = location of sprite for digit Vx.
Fx33 - LD B, Vx           &#x2705;? Load BCD from X into Memory[I]: Store BCD representation of Vx in memory locations I, I+1, and I+2.
Fx55 - LD [I], Vx         &#x2705;? Save Registers: Store registers V0 through Vx in memory starting at location I.
Fx65 - LD Vx, [I]         &#x2705;? Restore Registers: Read registers V0 through Vx from memory starting at location I.
</pre>
</tt>
</td></tr></table>
<hr/>
</center>
</div>


<div id="hex_to_binary" hidden>


<h3>CHIP-8 Program File Format (.ch8)</h3>

The common ".ch8" files used with CHIP-8 contain binary data which is more difficult to handle through a typical
web browser interface. For that reason, this program uses hexadecimal (hex) representations of binary files so they
can be easily copied and pasted. So to run a binary ".ch8" file, it must be converted to hex first. There are many
programs that can do this conversion. One of the most common is the UNIX/Linux "od" (octal dump) command. You can
use "od" to convert a binary ".ch8" file to a hexadecimal file with:<br/>
<br/>
$ od -v -tx1 -An filename<br/>
<br/>
For example:<br/>
<br/>
<tt>
$ od -v -tx1 -An Maze.ch8<br/>
a2 1e c2 01 32 01 a2 1a d0 14 70 04 30 40 12 00<br/>
60 00 71 04 31 20 12 00 12 18 80 40 20 10 20 40<br/>
80 10
</tt>
<br/>
<br/>
That output can be copied and pasted into the "Machine Code" window of this CHIP-8 simulator to run.
<hr/>

</div>




<div id="instruction_set" hidden>

<h3>RCA 1802 Instruction Set</h3>

<p/>
<hr/>
<p/>

</div>

<div id="examples" hidden>

<center>
<table>
<tr><th><h3>Example Programs</h3></th></tr>
<tr><td>
<table class="ex">

<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Generate a Maze">
;===========================;
; Generate a maze in CHIP-8 ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;   V2 used for random bit  ;
;===========================;

TOP: LD I,R3      ; Load sprite address
     RND V2,01    ; Put random bit in V2
     SE V2,01     ; Skip if V2=1 (random)
     LD I,R1      ; Load a different sprite
     DRW V0,V1,4  ; Draw at (V0,V1) 4 rows
     ADD V0,04    ; Add 4 to x coord
     SE V0,40     ; Skip if at end of V0
     JP TOP       ; Go back to top
     LD V0,00     ; At end so go back x=0
     ADD V1,04    ; Add 4 to y
     SE V1,20     ; Skip if end of y (done)
     JP TOP       ; Go back to top
END: JP END       ; Stay here ... forever

R1:  DATA 8040    ; Image data
R2:  DATA 2010    ; Image data
R3:  DATA 2040    ; Image data
R4:  DATA 8010    ; Image data
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw small box">
;===========================;
; Draw small box in CHIP-8  ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD I,BX      ; Load sprite address
     LD V0,1B     ; Load x
     LD V1,0B     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
END: JP END       ; Stay here ... forever
BX:  DATA FF81    ; Image data FF is top, 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 81FF    ; Image data 81 is sides, FF is bottom
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw large box">
;================================;
; Generate a large box in CHIP-8 ;
;================================;
; Registers:                     ;
;   V0 used for x                ;
;   V1 used for y                ;
;================================;

TOP: LD I,HZ      ; Load sprite address

     LD V0,04     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,0C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,14     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,1C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,24     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,2C     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,34     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD I,VT      ; Load sprite address

     LD V0,3B     ; Load x
     LD V1,05     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row

     LD V0,3B     ; Load x
     LD V1,0D     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row

     LD V0,3B     ; Load x
     LD V1,15     ; Load y
     DRW V0,V1,7  ; Draw at (V0,V1) 1 row

     LD I,HZ      ; Load sprite address

     LD V0,33     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,2B     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,23     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,1B     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,13     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,0B     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD V0,03     ; Load x
     LD V1,1B     ; Load y
     DRW V0,V1,1  ; Draw at (V0,V1) 1 row

     LD I,VT      ; Load sprite address

     LD V0,03     ; Load x
     LD V1,13     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row

     LD V0,03     ; Load x
     LD V1,0B     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 1 row

     LD V0,03     ; Load x
     LD V1,04     ; Load y
     DRW V0,V1,7  ; Draw at (V0,V1) 1 row

END: JP END       ; Stay here ... forever

HZ:  DATA FF00    ; Horizontal
VT:  DATA 8080    ; Vertical
     DATA 8080    ; Vertical
     DATA 8080    ; Vertical
     DATA 8080    ; Vertical
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw small XOR box">
;===========================;
;  Draw XOR box in CHIP-8   ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP:   LD V0,1E     ; Load x
       LD V1,0E     ; Load y
       LD VA,01     ; Load increment of 1
       CALL PIX     ; Call the PIX Subroutine

LOOP:  ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       CALL PIX     ; Call the PIX Subroutine

       ADD V1,VA    ; Increment y
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment y
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment y
       CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment y
       CALL PIX     ; Call the PIX Subroutine

       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Decrement x
       CALL PIX     ; Call the PIX Subroutine

       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Decrement y
       CALL PIX     ; Call the PIX Subroutine

       JP LOOP

PIX:   LD I,PX      ; Load sprite address
       DRW V0,V1,1  ; Draw at (V0,V1) 8 rows
       RET

PX:    DATA 8000    ; Image data leftmost bit set
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw Square Figure 8">
;===========================;
;  Draw sq fig 8 in CHIP-8  ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;   VA holds constant: 1    ;
;   VC holds a counter      ;
;   VD holds size of fig 8  ;
;   VE 2*VD for long lines  ;
;===========================;

TOP:   LD V0,1F     ; Load x at center of screen
       LD V1,10     ; Load y at center of screen
       LD VA,01     ; Load increment of 1
       LD VD,0D     ; Set the size of the figure 8
       LD VE,VD     ; Set VE for double lines
       SHL VE,VE    ; Double VE for double lines

       LD VC,VD     ; Load the count
       CALL HLPP    ; Draw Horizontal Line Right

LOOP:  LD VC,VD     ; Load the count
       CALL VLPP    ; Draw Vertical Line Down
       LD VC,VD     ; Load the count
       CALL HLPN    ; Draw Horizontal Line Left
       LD VC,VE     ; Load the count for double
       CALL VLPN    ; Draw 2x Vertical Line Up
       LD VC,VD     ; Load the count
       CALL HLPN    ; Draw Horizontal Line Left
       LD VC,VD     ; Load the count
       CALL VLPP    ; Draw Vertical Line Down
       LD VC,VE     ; Load the count for double
       CALL HLPP    ; Draw 2x Horizontal Line Right
       JP LOOP      ; Keep drawing

HLPP:  CALL PIX     ; Call the PIX Subroutine
       ADD V0,VA    ; Increment x
       SUB VC,VA    ; Decrement count
       SE  VC,00    ; Skip following when 0
       JP  HLPP
       RET

VLPP:  CALL PIX     ; Call the PIX Subroutine
       ADD V1,VA    ; Increment y
       SUB VC,VA    ; Decrement count
       SE  VC,00    ; Skip following when 0
       JP  VLPP
       RET

HLPN:  CALL PIX     ; Call the PIX Subroutine
       SUB V0,VA    ; Increment x
       SUB VC,VA    ; Decrement count
       SE  VC,00    ; Skip following when 0
       JP  HLPN
       RET

VLPN:  CALL PIX     ; Call the PIX Subroutine
       SUB V1,VA    ; Increment y
       SUB VC,VA    ; Decrement count
       SE  VC,00    ; Skip following when 0
       JP  VLPN
       RET

PIX:   LD I,PX      ; Load sprite address
       DRW V0,V1,1  ; Draw at (V0,V1) 1 row
       RET

PX:    DATA 8000    ; Image data leftmost bit set
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw boxes in-line">
;===========================;
; Generate boxes in CHIP-8  ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD I,BX      ; Load sprite address
     LD V0,0D     ; Load x
     LD V1,05     ; Load y
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     ADD V0,05
     ADD V1,02
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
END: JP END       ; Stay here ... forever
BX:  DATA FF81    ; Image data
     DATA 8181    ; Image data
     DATA 8181    ; Image data
     DATA 81FF    ; Image data
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw boxes via subroutine">
;===========================;
; Draw boxes via subroutine ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

TOP: LD V0,01     ; Load x
     LD V1,01     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,37     ; Load x
     LD V1,01     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,01     ; Load x
     LD V1,17     ; Load y
     CALL BOX     ; Call the Box Subroutine

     LD V0,37     ; Load x
     LD V1,17     ; Load y
     CALL BOX     ; Call the Box Subroutine

END: JP END       ; Stay here ... forever

BOX: LD I,BX      ; Load sprite address
     DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
     RET

BX:  DATA FF81    ; Image data FF is top, 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 8181    ; Image data 81 is sides
     DATA 81FF    ; Image data 81 is sides, FF is bottom
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Joe's COSMAC COOL">
;============================;
; Draw Joe's COSMAC ELF COOL ;
;============================;
; Registers:                 ;
;   V0 used for x            ;
;   V1 used for y            ;
;============================;

       LD I,IMG     ; Load first sprite address
       LD VA,08     ; Load size of each sprite
       LD V0,00     ; Initial x
       LD V1,00     ; Initial y

       LD V1,00     ; Load y
NEWR:  LD V0,00     ; Load x
DCOL:  CALL BOX     ; Call the Box Subroutine
       ADD I,VA     ; Move to next sprite
       ADD V0,VA    ; Move to next column
       SE V0,40     ; Check for end of row
       JP DCOL      ; Draw the next column
       ADD V1,VA    ; Move to next row
       SE V1,20     ; Check for end of rows
       JP NEWR      ; Start a new row

END:   JP END       ; Stay here ... forever

BOX:   DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
       RET

IMG:  DATA ff88
      DATA baba
      DATA ba88
      DATA ffff

      DATA ff8b
      DATA b988
      DATA ea8b
      DATA ffff

      DATA ffa2
      DATA 2a22
      DATA aaaa
      DATA ffff

      DATA ff3f
      DATA ffff
      DATA ff38
      DATA e7df

      DATA ffff
      DATA ffff
      DATA 13e0
      DATA c0c1

      DATA fffe
      DATA 9dfb
      DATA e71f
      DATA 03c0

      DATA ff0f
      DATA f37d
      DATA beff
      DATA ffff

      DATA ffff
      DATA ffff
      DATA ff7f
      DATA 7fbf

      DATA 8282
      DATA 9e9e
      DATA 8686
      DATA 9e9e

      DATA 7878
      DATA 7979
      DATA 7878
      DATA 7979

      DATA 3f3f
      DATA fffe
      DATA 7e7e
      DATA fdfd

      DATA bf7f
      DATA 7fff
      DATA fffe
      DATA feff

      DATA c1e3
      DATA ffff
      DATA 0f07
      DATA 070f

      DATA 8083
      DATA 83c7
      DATA ffff
      DATA ffff

      DATA 3f87
      DATA f1fc
      DATA ffff
      DATA fcd8

      DATA bfbf
      DATA df5f
      DATA 0f27
      DATA 272f

      DATA 8282
      DATA ffff
      DATA c782
      DATA 9292

      DATA 0909
      DATA ffff
      DATA 1c08
      DATA 4949

      DATA fdfe
      DATA feff
      DATA 6727
      DATA 2727

      DATA ffff
      DATA ff77
      DATA b7db
      DATA e3fc

      DATA ffff
      DATA ffff
      DATA ffff
      DATA ff30

      DATA ffff
      DATA ffdf
      DATA cebe
      DATA 3dfd

      DATA b0a0
      DATA 6040
      DATA c080
      DATA 8001

      DATA 2f2f
      DATA 2f6f
      DATA 5fdf
      DATA bfbf

      DATA 9e9e
      DATA 9e9e
      DATA 9282
      DATA c7ff

      DATA 4949
      DATA 4949
      DATA 4908
      DATA 1cff

      DATA 2727
      DATA 2727
      DATA 2720
      DATA 60ff

      DATA ffff
      DATA ffff
      DATA ffff
      DATA ffff

      DATA 8ff7
      DATA fbe0
      DATA dfe0
      DATA 9f3f

      DATA f1ee
      DATA de3f
      DATA df3f
      DATA 7fbf

      DATA 0386
      DATA dd73
      DATA 8fff
      DATA ffff

      DATA 7fff
      DATA ffff
      DATA ffff
      DATA ffff
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Draw CHIP-8 Digits">
;===========================;
;    Draw CHIP-8 Digits     ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

        ; TEST LD
        ; TEST CALL
        ; TEST RET
TOP:    CLS

        ; TEST the 16 numeric sprites with 2 loops

        LD VA,05     ; Amount to increment I (size of glyphs)
        LD V3,00     ; Load V3 with the value of '0'
        LD F,V3      ; Puts address of '0' (value of V3) in I
        LD V5,08     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop1: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
        ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop1   ; Continue with next glyph


        LD V5,13     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop2: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
        ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop2   ; Continue with next glyph

END:    JP END       ; Stay here ... forever
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="CHIP-8 Test Suite">
;===========================;
;     CHIP-8 Test Suite     ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;===========================;

        ; TEST LD
        ; TEST CALL
        ; TEST RET
TOP:    LD V0,01     ; Load x
        LD V1,01     ; Load y
        CALL BOX     ; Call the Box Subroutine

        ; TEST CLS
        CLS          ; Clear after first to test CLS

        LD V0,37     ; Load x
        LD V1,01     ; Load y
        CALL BOX     ; Call the Box Subroutine

        LD V0,01     ; Load x
        LD V1,17     ; Load y
        CALL BOX     ; Call the Box Subroutine

        LD V0,37     ; Load x
        LD V1,17     ; Load y
        CALL BOX     ; Call the Box Subroutine

        ; Screen should show 3 blocks since first was cleared
        ; Now that 3 blocks are drawn, use CLR to show failure


        ; TEST the 16 numeric sprites with 2 loops

        LD VA,05     ; Amount to increment I (size of glyphs)
        LD V3,00     ; Load V3 with the value of '0'
        LD F,V3      ; Puts address of '0' (value of V3) in I
        LD V5,0A     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop1: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
        ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop1   ; Continue with next glyph


        LD V5,11     ; Starting Row to draw (Y)
        LD V4,0C     ; Starting Col to draw (X)
        LD VC,00     ; Loop counter

NLoop2: DRW V4,V5,5  ; Draw at (V0,V1) 5 rows
        ADD V4,05    ; Move right by 5
        ADD I,VA     ; Move I to the next glyph
        ADD VC,01    ; Increment the Loop counter
        SE  VC,08    ; Skip branch when counter == 8
        JP  NLoop2   ; Continue with next glyph


        ; TEST JP
        JP JPOK
        CLS          ; Clear if JP fails

        ; TEST SE immediate
JPOK:   LD V0,55
        SE V0,55     ; Test SE skipping when equal
        CLS
        SE V0,44     ; Test SE not skipping when not equal
        SE V0,55     ; Test SE skipping when equal
        CLS

        ; TEST SNE immediate
        LD V0,55
        SNE V0,44    ; Test SNE skipping when not equal
        CLS
        SNE V0,55    ; Test SNE not skipping when equal
        SE V0,55
        CLS

        ; TEST SNE register
        LD V0,55
        LD V4,44
        SNE V0,V4    ; Test SNE skipping when not equal
        CLS
        LD V4,55
        SNE V0,V4    ; Test SNE not skipping when equal
        SE V0,55
        CLS

        ; TEST SE register
        LD V0,55
        LD V4,44
        LD V5,55
        SE V0,V5     ; Test SE skipping when equal
        CLS
        SE V0,V4     ; Test SE not skipping when not equal
        SE V0,55     ; Test SE skipping when equal
        CLS

        ; TEST LD register to register
        LD V0,00
        LD V5,55
        LD V0,V5
        SE V0,55
        CLS

        ; TEST OR Vx,Vy (Vx = Vx | Vy)
        LD V4,94     ; 10010100 = 94
        LD V5,CE     ; 11001110 = CE
        OR V5,V4
        SE V5,DE     ; 11011110 = DE
        CLS

        ; TEST AND Vx,Vy (Vx = Vx & Vy)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,EE    ; 11101110 = EE
        AND V5,V4
        SE  V5,A4    ; 10100100 = A4
        CLS

        ; TEST XOR Vx,Vy (Vx = Vx ^ Vy)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,ED    ; 11101101 = ED
        XOR V5,V4
        SE  V5,59    ; 01011001 = 59
        CLS

        ; TEST ADD Vx,Vy (Vx = Vx + Vy)
        LD  V4,34    ; 00110100 = 34
        LD  V5,6D    ; 01101101 = 6D
        ADD V5,V4
        SE  V5,A1    ; 10100001 = A1
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD  V4,34    ; 00110100 = 34
        LD  V5,6D    ; 01101101 = 6D
        ADD V5,V4
        SE  V5,A1    ; 10100001 = A1
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD  V4,A1    ; 10100001 = A1
        LD  V5,6D    ; 01101101 = 6D
        SUB V4,V5
        SE  V4,34    ; 00110100 = 34
        CLS

        ; TEST SUB Vx,Vy (Vx = Vx - Vy)
        LD   V4,A1   ; 10100001 = A1
        LD   V5,6D   ; 01101101 = 6D
        SUBN V5,V4
        SE   V5,34   ; 00110100 = 34
        CLS

        ; TEST SHR Vx,Vy (Vx = Vy >> 1)
        LD  V4,B4    ; 10110100 = B4
        LD  V5,A7    ; 10100111 = A7
        SHR V5,V4
        SE  V5,5A    ; 01011010 = 5A
        CLS

        ; TEST SHR Vx,Vy (Vx = Vy >> 1)
        LD  V5,A7    ; 10100111 = A7
        SHR V5,V5
        SE  V5,53    ; 01010011 = 53
        CLS

        ; TEST SHL Vx,Vy (Vx = Vy LL 1) LL replaces ((
        LD  V4,08    ; 00001000 = 08
        LD  V5,AA    ; 10101010 = AA
        SHL V5,V4
        SE  V5,10    ; 00010000 = 10
        CLS

        ; TEST SHL Vx,Vy (Vx = Vy LL 1) LL replaces ((
        LD  V5,A7    ; 10100111 = A7
        SHL V5,V5
        SE  V5,4E    ; 01001110 = 4E
        CLS

        ; TEST the Delay timer by drawing digits

        LD V4,04     ; Set value for x
        LD V5,04     ; Set value for y

        LD V8,00     ; Index of each digit to display
        LD V9,01     ; Amount to increase each time

NEXTD:  CLS
        LD V3,V8     ; Load V3 with the next index value
        LD F,V3      ; Puts address of character in I
        DRW V4,V5,5  ; Draw at (V0,V1) 5 rows should show "1"

        LD V6,1E     ; Load ticks of 60Hz timer in V6 (3C=60,1E=30)
        LD DT,V6     ; Load the timer ticks from V6 into DT
TLoopN: LD V7,DT     ; Get the the timer value in V7
        SE V7,00     ; Skip branch when V7(timer) == 0
        JP TLoopN    ; Jump back until timer is 0
        ADD V8,V9    ; Increment V8 for next character
        SE V8,10     ; Skip when V8 = 16 (10x)
        JP NEXTD

        ; Draw DONE

        CLS
        LD V2,06     ; Character width (including space)
        LD V0,14     ; Starting x
        LD V1,0C     ; Starting y
        LD I,DONE_D  ; Load address of D
        DRW V0,V1,5  ; Draw the D
        ADD V0,V2    ; Move x to next position
        LD I,DONE_O  ; Load address of O
        DRW V0,V1,5  ; Draw the O
        ADD V0,V2    ; Move x to next position
        LD I,DONE_N  ; Load address of N
        DRW V0,V1,5  ; Draw the N
        ADD V0,V2    ; Move x to next position
        LD I,DONE_E  ; Load address of E!
        DRW V0,V1,5  ; Draw the E!


END:    JP END       ; Stay here ... forever

BOX:    LD I,BX      ; Load sprite address
        DRW V0,V1,8  ; Draw at (V0,V1) 8 rows
        RET

BX:     DATA FF81    ; Image data FF is top, 81 is sides
        DATA 8181    ; Image data 81 is sides
        DATA 8181    ; Image data 81 is sides
        DATA 81FF    ; Image data 81 is sides, FF is bottom

DONE_D: DATA E090  ; D
        DATA 9090
        DATA E000
DONE_O: DATA F090  ; O
        DATA 9090
        DATA F000
DONE_N: DATA 90D0  ; N
        DATA F0B0
        DATA 9000
DONE_E: DATA F282  ; E!
        DATA E280
        DATA F200
</pre></td></tr>


                                                             <!-- Attempt to use name to map keys --> 
<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" name="[[4,8],[6,9],[1,10],[9,7],[5,0]]" id="Tank (not working yet)">
;===========================;
;   Tank  (mostly working)  ;
;===========================;
;   Disassembled from Hex   ;
;                           ;
; On-Screen Hex Keys:       ;
;          1=Up             ;
;     4=Lt 5=Shoot 6=Rt     ;
;          9=Down           ;
;                           ;
; Keyboard keypad Keys:     ;
;          8=Up             ;
;     4=Lt 5=Shoot 6=Rt     ;
;          2=Down           ;
;===========================;
     JP 230
202: ADD V6,FB
     LD V0,20
     SUB V0,V6
     SNE VF,00
     LD V6,00
     JP 384
     SYS 0FF
     SYS 000
212: SYS 001
     SYS 00C
     SYS A00
     JP 902
     SYS 406
     SYS 802
     SYS 203
     CALL C00
     SYS F00
     SYS 205
     CALL E08
     SYS 000
     SYS 205
     SYS 000
     SYS 000
230: LD VE,00
     LD VD,A0
     LD VA,08
     LD V9,06
     LD V8,04
     LD V7,02
     LD V6,19
     LD V4,10
     LD V3,0C
     LD V2,00
     LD V1,06
     LD I,212
     LD [I],VA
24A: CALL 3D4
     LD V0,40
     LD DT,V0
250: LD V0,DT
     SE V0,00
     JP 250
     CALL 3D4
     CALL 30A
     CALL 362
     LD I,212
     LD V5,[I]
     CALL 2AE
262: CALL 2C6
     CALL 2EC
     SE VF,01
     CALL 314
     SE VF,01
     CALL 2EC
     SE VF,01
     CALL 2EC
     SE VF,01
     CALL 27C
     SNE VF,01
     JP 366
     JP 262
27C: LD I,212
     LD V5,[I]
     SNE V6,00
     SE V5,00
     JP 288
     JP 38C
288: SKNP V7
     LD V2,09
     SKNP V8
     LD V2,04
     SKNP V9
     LD V2,06
     SKNP VA
     LD V2,01
     SNE V2,00
     RET
     CALL 2AE
     LD V1,V2
     CALL 39A
     CALL 3AC
     LD VC,01
     LD V2,00
     LD VF,00
     LD I,212
     LD [I],V5
2AE: LD I,3FF
     SNE V1,01
     LD V0,00
     SNE V1,04
     LD V0,13
     SNE V1,06
     LD V0,0D
     SNE V1,09
     LD V0,06
     ADD I,V0
     DRW V3,V4,7
     RET
2C6: LD V0,05
     SKP V0
     RET
     SNE V5,0F
     RET
     LD V5,0F
     ADD V6,FF
     LD I,212
     LD [I],V5
     ADD V4,03
     ADD V3,03
     CALL 39A
     CALL 39A
     CALL 39A
     LD I,223
     LD [I],V5
     LD I,419
     DRW V3,V4,1
     RET
2EC: LD I,223
     LD V5,[I]
     SNE V5,00
     RET
     LD I,419
     DRW V3,V4,1
     CALL 39A
     LD VC,02
     CALL 3BE
     SNE VB,BB
     JP 30A
     DRW V3,V4,1
304: LD I,223
     LD [I],V5
     RET
30A: LD V5,00
     LD V0,00
     LD I,217
     LD [I],V0
     JP 304
314: LD I,21D
     LD V5,[I]
     SE V5,0F
     JP 344
     LD I,41A
     DRW V3,V4,5
     SE V2,00
     JP 332
     RND V1,03
     LD I,219
     ADD I,V1
     LD V0,[I]
     LD V1,V0
     RND V2,0F
     ADD V2,01
332: CALL 39A
     LD I,41A
     LD VC,03
     ADD V2,FF
     LD VF,00
     DRW V3,V4,5
33E: LD I,21D
     LD [I],V5
     RET
344: RND V4,07
     LD I,41F
     ADD I,V4
     LD V0,[I]
     LD V3,V0
     LD I,427
     ADD I,V4
     LD V0,[I]
     LD V4,V0
     LD I,41A
     DRW V3,V4,5
     LD V0,20
     LD ST,V0
     LD V5,0F
     JP 33E
362: LD V5,00
     JP 33E
366: SNE VC,01
     JP 202
     SNE VC,02
     JP 382
     LD I,223
     LD V5,[I]
     SNE V5,00
     JP 202
     LD I,419
     DRW V3,V4,1
     LD VF,00
     DRW V3,V4,1
     SE VF,01
     JP 202
382: ADD VE,0A
384: LD V0,40
     LD ST,V0
     CLS
     JP 24A
38C: CLS
     CALL 3D4
     LD V0,60
     LD ST,V0
394: JP 394
     LD VE,00
     JP 384
39A: SNE V1,01
     ADD V4,FF
     SNE V1,04
     ADD V3,FF
     SNE V1,06
     ADD V3,01
     SNE V1,09
     ADD V4,01
     RET
3AC: SNE V4,00
     ADD V4,01
     SNE V3,00
     ADD V3,01
     SNE V3,38
     ADD V3,FF
     SNE V4,18
     ADD V4,FF
     RET
3BE: LD VB,00
     SNE V4,00
     JP 3CE
     SNE V3,00
     JP 3CE
     SNE V3,3F
     JP 3CE
     SNE V4,1F
3CE: LD VB,BB
     LD VF,00
     RET
3D4: LD V3,08
     LD V4,08
     LD I,229
     LD B,VE
     LD V2,[I]
     CALL 3EC
     LD V3,28
     LD I,229
     LD B,V6
     LD V2,[I]
     CALL 3F2
     RET
3EC: LD F,V0
     DRW V3,V4,5
     ADD V3,06
3F2: LD F,V1
     DRW V3,V4,5
     ADD V3,06
     LD F,V2
     DRW V3,V4,5
     RET
     SYS 110
     DATA 547C
     LD VC,7C
     ADD VC,44
406: ADD VC,7C
     LD VC,7C
     SE V4,V1
     SYS 0FC
     ADD V8,6E
     ADD V8,FC
     SYS 03F
     JP E76
     JP E3F
     SYS 080
41A: LD I,870
     DATA F870
     LD I,80B
     JP B28
     SE V8,30
     CALL 010
     SYS 000
     SYS 000
     SYS 81B
     JP B1B
     JP 804
</pre></td></tr>
                                                             <!-- Attempt to use name to map keys -->
<tr class="ex"><td class="ex" valign="top"><pre class="exhex" name="[[4,8],[6,9],[1,10],[9,7],[5,0]]" id="Tank Hex (not working yet)">
 12 30 76 fb 60 20 80 65 4f 00 66 00 13 84 00 ff
 00 00 00 01 00 0c 0a 00 19 02 04 06 08 02 02 03
 2c 00 0f 00 02 05 2e 08 00 00 02 05 00 00 00 00
 6e 00 6d a0 6a 08 69 06 68 04 67 02 66 19 64 10
 63 0c 62 00 61 06 a2 12 fa 55 23 d4 60 40 f0 15
 f0 07 30 00 12 50 23 d4 23 0a 23 62 a2 12 f5 65
 22 ae 22 c6 22 ec 3f 01 23 14 3f 01 22 ec 3f 01
 22 ec 3f 01 22 7c 4f 01 13 66 12 62 a2 12 f5 65
 46 00 35 00 12 88 13 8c e7 a1 62 09 e8 a1 62 04
 e9 a1 62 06 ea a1 62 01 42 00 00 ee 22 ae 81 20
 23 9a 23 ac 6c 01 62 00 6f 00 a2 12 f5 55 a3 ff
 41 01 60 00 41 04 60 13 41 06 60 0d 41 09 60 06
 f0 1e d3 47 00 ee 60 05 e0 9e 00 ee 45 0f 00 ee
 65 0f 76 ff a2 12 f5 55 74 03 73 03 23 9a 23 9a
 23 9a a2 23 f5 55 a4 19 d3 41 00 ee a2 23 f5 65
 45 00 00 ee a4 19 d3 41 23 9a 6c 02 23 be 4b bb
 13 0a d3 41 a2 23 f5 55 00 ee 65 00 60 00 a2 17
 f0 55 13 04 a2 1d f5 65 35 0f 13 44 a4 1a d3 45
 32 00 13 32 c1 03 a2 19 f1 1e f0 65 81 00 c2 0f
 72 01 23 9a a4 1a 6c 03 72 ff 6f 00 d3 45 a2 1d
 f5 55 00 ee c4 07 a4 1f f4 1e f0 65 83 00 a4 27
 f4 1e f0 65 84 00 a4 1a d3 45 60 20 f0 18 65 0f
 13 3e 65 00 13 3e 4c 01 12 02 4c 02 13 82 a2 23
 f5 65 45 00 12 02 a4 19 d3 41 6f 00 d3 41 3f 01
 12 02 7e 0a 60 40 f0 18 00 e0 12 4a 00 e0 23 d4
 60 60 f0 18 13 94 6e 00 13 84 41 01 74 ff 41 04
 73 ff 41 06 73 01 41 09 74 01 00 ee 44 00 74 01
 43 00 73 01 43 38 73 ff 44 18 74 ff 00 ee 6b 00
 44 00 13 ce 43 00 13 ce 43 3f 13 ce 44 1f 6b bb
 6f 00 00 ee 63 08 64 08 a2 29 fe 33 f2 65 23 ec
 63 28 a2 29 f6 33 f2 65 23 f2 00 ee f0 29 d3 45
 73 06 f1 29 d3 45 73 06 f2 29 d3 45 00 ee 01 10
 54 7c 6c 7c 7c 44 7c 7c 6c 7c 54 10 00 fc 78 6e
 78 fc 00 3f 1e 76 1e 3f 00 80 a8 70 f8 70 a8 0b
 1b 28 38 30 20 10 00 00 00 00 08 1b 1b 1b 18 04
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" name="[[2,2],[4,7],[6,8],[5,9]]" id="Tetris">
;===========================;
;          Tetris           ;
;===========================;
;                           ;
;  4          5         6   ;
; Left      Rotate    Right ;
;                           ;
;             2             ;
;            Drop           ;
;                           ;
;===========================;
     LD I,2B4
     CALL 3E6
     CALL 2B6
206: ADD V0,01
     DRW V0,V1,1
     SE V0,25
     JP 206
20E: ADD V1,FF
     DRW V0,V1,1
     LD V0,1A
     DRW V0,V1,1
     LD V0,25
     SE V1,00
     JP 20E
21C: RND V4,70
     SNE V4,70
     JP 21C
     RND V3,03
     LD V0,1E
     LD V1,03
     CALL 25C
22A: LD DT,V5
     DRW V0,V1,4
     SE VF,01
     JP 23C
     DRW V0,V1,4
     ADD V1,FF
     DRW V0,V1,4
     CALL 340
     JP 21C
23C: SKNP V7
     CALL 272
     SKNP V8
     CALL 284
     SKNP V9
     CALL 296
     SKP V2
     JP 250

24C: DATA 6600  ; LD V6,00
24E: DATA F615  ; LD DT,V6

250: LD V6,DT
     SE V6,00
     JP 23C
     DRW V0,V1,4
     ADD V1,01
     JP 22A
25C: LD I,2C4
     ADD I,V4
     LD V6,00
     SNE V3,01
     LD V6,04
     SNE V3,02
     LD V6,08
     SNE V3,03
     LD V6,0C
     ADD I,V6
     RET
272: DRW V0,V1,4
     ADD V0,FF
     CALL 334
     SE VF,01
     RET
     DRW V0,V1,4
     ADD V0,01
     CALL 334
     RET
284: DRW V0,V1,4
     ADD V0,01
     CALL 334
     SE VF,01
     RET
     DRW V0,V1,4
     ADD V0,FF
     CALL 334
     RET
296: DRW V0,V1,4
     ADD V3,01
     SNE V3,04
     LD V3,00
     CALL 25C
     CALL 334
     SE VF,01
     RET
     DRW V0,V1,4
     ADD V3,FF
     SNE V3,FF
     LD V3,03
     CALL 25C
     CALL 334
     RET

2B4: DATA 8000

2B6: LD V7,05
     LD V8,06
     LD V9,04
     LD V1,1F
     LD V5,10
     LD V2,07
     RET

2C4: DATA 40E0
2C6: DATA 0000
2C8: DATA 40C0
2CA: DATA 4000
2CC: DATA 00E0
2CE: DATA 4000
2D0: DATA 4060
2D2: DATA 4000
2D4: DATA 4040
2D6: DATA 6000
2D8: DATA 20E0
2DA: DATA 0000
2DC: DATA C040
2DE: DATA 4000
2E0: DATA 00E0
2E2: DATA 8000
2E4: DATA 4040
2E6: DATA C000
2E8: DATA 00E0
2EA: DATA 2000
2EC: DATA 6040
2EE: DATA 4000
2F0: DATA 80E0
2F2: DATA 0000
2F4: DATA 40C0
2F6: DATA 8000
2F8: DATA C060
2FA: DATA 0000
2FC: DATA 40C0
2FE: DATA 8000
300: DATA C060
302: DATA 0000
304: DATA 80C0
306: DATA 4000
308: DATA 0060
30A: DATA C000
30C: DATA 80C0
30E: DATA 4000
310: DATA 0060
312: DATA C000
314: DATA C0C0
316: DATA 0000
318: DATA C0C0
31A: DATA 0000
31C: DATA C0C0
31E: DATA 0000
320: DATA C0C0
322: DATA 0000
324: DATA 4040
326: DATA 4040
328: DATA 00F0
32A: DATA 0000
32C: DATA 4040
32E: DATA 4040
330: DATA 00F0
332: DATA 0000

334: DRW V0,V1,4
     LD V6,35
338: ADD V6,FF
     SE V6,00
     JP 338
     RET
340: LD I,2B4
     LD VC,V1
     SE VC,1E
     ADD VC,01
     SE VC,1E
     ADD VC,01
     SE VC,1E
     ADD VC,01
350: CALL 35E
     SNE VB,0A
     CALL 372
     SNE V1,VC
     RET
     ADD V1,01
     JP 350
35E: LD V0,1B
     LD VB,00
362: DRW V0,V1,1
     SE VF,00
     ADD VB,01
     DRW V0,V1,1
     ADD V0,01
     SE V0,25
     JP 362
     RET
372: LD V0,1B
374: DRW V0,V1,1
     ADD V0,01
     SE V0,25
     JP 374
     LD VE,V1
     LD VD,VE
     ADD VE,FF
382: LD V0,1B
     LD VB,00
386: DRW V0,VE,1
     SE VF,00
     JP 390
     DRW V0,VE,1
     JP 394
390: DRW V0,VD,1
     ADD VB,01
394: ADD V0,01
     SE V0,25
     JP 386
     SNE VB,00
     JP 3A6
     ADD VD,FF
     ADD VE,FF
     SE VD,01
     JP 382
3A6: CALL 3C0
     SE VF,01
     CALL 3C0
     ADD VA,01
     CALL 3C0
     LD V0,VA
     LD VD,07
     AND V0,VD
     SNE V0,04
     ADD V5,FE
     SNE V5,02
     LD V5,04
     RET
3C0: LD I,700
     LD [I],V2
     LD I,804
     LD B,VA
     LD V2,[I]
     LD F,V0
     LD VD,32
     LD VE,00
     DRW VD,VE,5
     ADD VD,05
     LD F,V1
     DRW VD,VE,5
     ADD VD,05
     LD F,V2
     DRW VD,VE,5
     LD I,700
     LD V2,[I]
     LD I,2B4
     RET
3E6: LD VA,00
     LD V0,19
     RET
3EC: DATA 3723</pre></td></tr>

<tr class="ex"><td class="ex" valign="top"><pre class="exhex" id="Tetris Hex (not working yet)">
 a2 b4 23 e6 22 b6 70 01 d0 11 30 25 12 06 71 ff
 d0 11 60 1a d0 11 60 25 31 00 12 0e c4 70 44 70
 12 1c c3 03 60 1e 61 03 22 5c f5 15 d0 14 3f 01
 12 3c d0 14 71 ff d0 14 23 40 12 1c e7 a1 22 72
 e8 a1 22 84 e9 a1 22 96 e2 9e 12 50 66 00 f6 15
 f6 07 36 00 12 3c d0 14 71 01 12 2a a2 c4 f4 1e
 66 00 43 01 66 04 43 02 66 08 43 03 66 0c f6 1e
 00 ee d0 14 70 ff 23 34 3f 01 00 ee d0 14 70 01
 23 34 00 ee d0 14 70 01 23 34 3f 01 00 ee d0 14
 70 ff 23 34 00 ee d0 14 73 01 43 04 63 00 22 5c
 23 34 3f 01 00 ee d0 14 73 ff 43 ff 63 03 22 5c
 23 34 00 ee 80 00 67 05 68 06 69 04 61 1f 65 10
 62 07 00 ee 40 e0 00 00 40 c0 40 00 00 e0 40 00
 40 60 40 00 40 40 60 00 20 e0 00 00 c0 40 40 00
 00 e0 80 00 40 40 c0 00 00 e0 20 00 60 40 40 00
 80 e0 00 00 40 c0 80 00 c0 60 00 00 40 c0 80 00
 c0 60 00 00 80 c0 40 00 00 60 c0 00 80 c0 40 00
 00 60 c0 00 c0 c0 00 00 c0 c0 00 00 c0 c0 00 00
 c0 c0 00 00 40 40 40 40 00 f0 00 00 40 40 40 40
 00 f0 00 00 d0 14 66 35 76 ff 36 00 13 38 00 ee
 a2 b4 8c 10 3c 1e 7c 01 3c 1e 7c 01 3c 1e 7c 01
 23 5e 4b 0a 23 72 91 c0 00 ee 71 01 13 50 60 1b
 6b 00 d0 11 3f 00 7b 01 d0 11 70 01 30 25 13 62
 00 ee 60 1b d0 11 70 01 30 25 13 74 8e 10 8d e0
 7e ff 60 1b 6b 00 d0 e1 3f 00 13 90 d0 e1 13 94
 d0 d1 7b 01 70 01 30 25 13 86 4b 00 13 a6 7d ff
 7e ff 3d 01 13 82 23 c0 3f 01 23 c0 7a 01 23 c0
 80 a0 6d 07 80 d2 40 04 75 fe 45 02 65 04 00 ee
 a7 00 f2 55 a8 04 fa 33 f2 65 f0 29 6d 32 6e 00
 dd e5 7d 05 f1 29 dd e5 7d 05 f2 29 dd e5 a7 00
 f2 65 a2 b4 00 ee 6a 00 60 19 00 ee 37 23
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exsrc" id="Invaders (not working yet)">
;===========================;
;  Invaders  (not working)  ;
;===========================;
;   Disassembled from Hex   ;
;===========================;
200: JP 225
     SE V3,V5
     SNE V1,43
206: SNE V5,20
     SNE V9,4E
     DATA 5641
     SNE V4,45
     DATA 5253
     CALL 076
     SE V0,2E
     SE V9,20
     SNE V2,79
218: CALL 044
     LD V1,76
     LD V9,64
     CALL 057
     SNE V9,4E
     DATA 5445
     SE V2,V6
     SYS 061
     SYS 062
     SYS 8A3
     DRW V3,VD,0
     JP 871
230: SYS 8F2
     JP E31
     CALL 012
     CALL D70
     SYS 861
     SYS 030
     SNE V0,12
     CALL D69
     SYS 56C
     JP 56E
     SYS 023
     LD V7,V6
     SYS AF0
     JP 5F0
     SYS 730
     SYS 012
     SNE VB,23
     SHL V7,V7
     SYS 112
     SNE V5,66
     SYS 068
     JP C69
     SYS 06A
     SYS 46B
     SYS A6C
262: SYS 46D
     SE VC,6E
     SYS F00
     DATA E023
26A: LD VB,23
     SNE V7,FD
     JP 560
     SYS 4E0
     DATA 9E12
     ADD VD,23
     LD VB,38
     SYS 078
     DATA FF23
     LD VB,60
     SYS 6E0
     DATA 9E12
     XOR VB,V2
     LD VB,38
     SE V9,78
     SYS 123
     LD VB,36
     SYS 012
     SNE VF,V6
     SYS 5E0
     DATA 9E12
     DATA E966
     SYS 165
     JP B84
     XOR V0,VA
     RND VF,D4
     DATA 51A3
     RND VF,D4
     DATA 5175
     DATA FF35
     DATA FF12
2A8: LD I,D66
     SYS 012
     DATA E9D4
     DATA 513F
     SYS 112
     DATA E9D4
     DATA 5166
     SYS 083
     SNE V0,73
     SYS 383
     JP V0,562
     DATA F883
     CALL 262
     SYS 833
     SYS 012
     RND V9,23
     ADD V3,82
     SYS 643
     SYS 812
     DRW V3,V3,3
     JP 012
     DRW V5,V2,3
     ADD V3,82
     SYS 633
     JP 812
     DRW VD,V2,3
     ADD V3,82
     SYS 643
     CALL 012
     DATA E733
     CALL 812
     DATA E923
     ADD V3,3E
     SYS 013
     SYS 779
     SYS 649
     JP 869
     SYS 06A
     SYS 46B
     SYS A6C
     SYS 47D
     DATA F46E
     SYS F00
2FE: DATA E023
     SNE V7,23
     LD VB,FD
     JP 512
     LD VF,F7
     SYS 737
     SYS 012
     LD VF,FD
     JP 523
     SNE V7,8B
     LD I,43B
     JP 213
     JP B7C
     SYS 26A
     DATA FC3B
     SYS 213
     CALL 37C
     SYS 26A
     SYS 423
     SNE V7,3C
     JP 812
     LD VF,00
     DATA E0A4
     DRW V3,V6,0
     JP 461
     SYS 862
     SYS FD0
     JP F70
     SYS 8F2
     JP E30
     CALL C13
     SE V3,F0
     SYS A00
     DATA E0A6
     DATA F4FE
     LD V5,12
     CALL 5A3
     JP V0,7F9
     JP E61
     SYS 823
     DATA 5F81
     SYS 623
     DATA 5F81
     SYS 623
     DATA 5F81
     SYS 623
     DATA 5F7B
     DRW V0,V0,0
     DATA EE80
     DATA E080
     JP 230
     SYS 0DB
     RND V6,7B
     SYS C00
     DATA EEA3
     RND VF,60
     JP CD8
     SYS 400
     DATA EE23
     SNE V7,8E
     CALL 323
     SNE V7,60
     SYS 5F0
37C: JP 8F0
     JP 5F0
     SYS 730
     SYS 013
     ADD VF,00
     DATA EE6A
     SYS 08D
     DATA E06B
     SYS 4E9
     LD I,112
     DATA 57A6
     SYS 2FD
     JP EF0
     LD V5,30
     DATA FF13
     LD I,56A
     SYS 06B
     SYS 46D
     SYS 16E
     SYS 113
     SUB VD,VA
     SYS 0F0
     JP EDB
     RND V6,7B
     SYS 87D
     SYS 17A
     SYS 13A
     SYS 713
     LD VD,V0
     DATA EE3C
     ADD VE,FF
     DATA FF99
     DATA 997E
     DATA FFFF
     CALL 424
     DATA E77E
     DATA FF3C
     SE VC,7E
     DRW VB,V8,1
     SNE V2,3C
     ADD VE,FF
     DRW VB,V1,0
     SE V8,7C
     DATA FE00
     SYS 07F
     SYS 03F
     SYS 07F
     SYS 000
     SYS 001
     SYS 101
     SYS 303
     SYS 303
     SYS 000
     SE VF,20
     CALL 020
     CALL 020
     CALL 020
     CALL 03F
     SYS 808
     DATA FF00
     SYS 0FE
     SYS 0FC
     SYS 0FE
     SYS 000
     SYS 07E
     SNE V2,42
400: LD V2,62
     LD V2,62
404: SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     ADD VD,00
     SNE V1,7D
     SYS 57D
     ADD VD,00
     SYS 0C2
     RND V2,C6
     SNE V4,6C
     CALL 838
424: SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     DATA F710
     JP 4F7
     DATA F704
     SYS 400
     SYS 07C
     SNE V4,FE
     RND V2,C2
     RND V2,C2
     SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     DATA EF20
     CALL 8E8
     DATA E82F
     CALL F00
     SYS 0F9
     SUB V5,VC
     RND V5,C5
     RND V5,F9
     SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     JP V0,E00
     CALL 030
     CALL 0BE
     JP V0,E00
     SYS 0F7
     SYS 4E7
     SUB V5,V8
     ADD V4,VF
     SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     SYS 07F
     SYS 03F
     SYS 07F
     SYS 000
     SYS 0EF
     CALL 8EF
     CLS
     LD V0,6F
     SYS 000
     DATA FF00
     SYS 000
     SYS 000
     SYS 000
     SYS 0FF
     SYS 000
     DATA FF00
     SYS 0FE
     SYS 0FC
     SYS 0FE
     SYS 000
     SYS 0C0
     SYS 0C0
     RND V0,C0
     RND V0,C0
     SYS 000
     DATA FC04
     SYS 404
     SYS 404
     SYS 404
     SYS 4FC
     JP 010
     DATA FFF9
     DATA 81B9
     DATA 8B9A
     DATA 9AFA
     SYS 0FA
     DATA 8A9A
     DATA 9A9B
4E0: DATA 99F8
     DATA E625
     CALL 5F4
     SE V4,34
     SE V4,00
     JP 714
     SE V4,37
     SE V6,26
     RND V7,DF
     SE V0,V5
     DATA 5CD8
     DRW V8,VD,F
     SYS 0DF
     JP 11F
4FC: JP 21B
     JP 9D9
     ADD VC,44
     DATA FE86
     SHR V6,V8
     DATA FC84
     DATA FE82
     SHL V2,VF
     DATA FE80
     RND V0,C0
     RND V0,FE
512: DATA FC82
     RND V2,C2
     RND V2,FC
     DATA FE80
     DATA F8C0
     RND V0,FE
     DATA FE80
     DATA F0C0
     RND V0,C0
     DATA FE80
     JP V0,E86
     SHL V6,VF
     SHR V6,V8
     DATA FE86
     SHR V6,V8
     JP 010
     JP 010
     JP 010
     JP 818
     JP 848
     SNE V8,78
     SNE VC,V9
     JP V0,0C0
     JP V0,09C
     LD V0,V8
     RND V0,C0
     RND V0,FE
     DATA EE92
     DATA 9286
     SHR V6,V8
     DATA FE82
     SHR V6,V8
     SHR V6,V8
     ADD VC,82
     SHR V6,V8
     DATA 867C
     DATA FE82
     DATA FEC0
     RND V0,C0
560: ADD VC,82
562: RND V2,CA
     RND V4,7A
     DATA FE86
     DATA FE90
56A: DATA 9C84
56C: DATA FEC0
56E: DATA FE02
     SYS 2FE
     DATA FE10
     SE V0,30
     SE V0,30
     AND V2,V8
     RND V2,C2
     RND V2,FE
     AND V2,V8
     SHL V2,VE
     SE V8,10
     SHR V6,V8
     DATA 9692
     DATA 92EE
     ADD V2,V4
     SE V8,38
     SNE V4,82
     AND V2,V8
     DATA FE30
     SE V0,30
     DATA FE02
     JP EF0
     SHL V0,VF
     SYS 000
     SYS 000
     SYS 606
     SYS 000
     SYS 060
     LD V0,C0
     SYS 000
     SYS 000
     SYS 000
     JP 818
     JP 818
     SYS 018
     ADD VC,C6
     SYS C18
     SYS 018
     SYS 000
     DATA FEFE
     SYS 000
     DATA FE82
     SHR V6,V8
     SHL V6,VF
     SYS 808
     SYS 818
     JP 818
     DATA FE02
     DATA FEC0
     RND V0,FE
     DATA FE02
     JP E06
     SYS 6FE
     ADD V4,VC
     RND V4,FE
     SYS 404
     DATA FE80
5E0: DATA FE06
     SYS 6FE
     RND V0,C0
     RND V0,FE
     SHL V2,VF
     DATA FE02
     SYS 206
     SYS 606
5F0: ADD VC,44
     DATA FE86
5F4: SHL V6,VF
     DATA FE82
     DATA FE06
     SYS 606
     SNE V4,FE
     SNE V4,44
     DATA FE44
     LD I,8A8
     LD I,8A8
606: LD I,8A8
     LD I,86C
     SE VA,V0
     SYS C18
     LD I,830
     SNE VE,7E
     SYS 012
     JP 866
     LD VC,A8
     DATA 5A66
     DATA 5424
     LD V6,00
     SNE V8,48
     JP 812
     LD I,806
     DATA 90A8
     JP 200
     ADD VE,30
     JP 2A8
     LD V4,V3
     SNE VE,72
     JP 866
     LD I,8A8
     LD I,8A8
     LD I,8A8
     DATA 9054
     ADD V8,A8
     SNE V8,78
     LD VC,72
     LD I,812
     JP 86C
     ADD V2,66
     SE V4,V9
     LD I,872
     CALL A18
     LD I,830
     SNE VE,7E
     SYS 012
     JP 866
     LD VC,A8
     ADD V2,54
     LD I,85A
     LD V6,18
     ADD VE,18
     SNE VE,72
     LD I,872
     CALL A18
     SE V0,66
     LD I,830
     SNE VE,7E
     SYS 06C
     SE V0,54
     SNE VE,9C
     LD I,8A8
     LD I,8A8
     LD I,8A8
     LD I,848
     DATA 547E
     JP 8A8
     DATA 9054
     ADD V8,66
     LD I,86C
     CALL A30
     DATA 5AA8
     LD V4,V3
     ADD V2,2A
     LD I,8D8
     LD I,800
     SNE VE,12
     LD I,8E4
     LD I,2A8
     SYS 04E
     JP 2A8
     LD VC,2A
     DATA 5454
     ADD V2,A8
     LD V4,V3
     ADD V2,2A
     LD I,8DE
     DATA 9CA8
     ADD V2,2A
     JP 8A8
     SYS C54
     SNE V8,5A
     ADD V8,72
     JP 866
     LD I,872
     JP 842
     SNE V2,6C
     LD I,872
     CALL A00
     ADD V2,A8
     ADD V2,2A
     JP 8A8
     SE V0,4E
     ADD VE,00
     JP 218
     LD V6,6C
     LD I,830
     SNE VE,0C
     LD V6,18
     SYS 06C
     JP 8A8
     ADD V2,2A
     JP 830
     LD V6,A8
     JP E54
     LD V6,0C
     JP 89C
6E0: LD I,824
     DATA 5454
     JP 2A8
     SNE V2,78
     SYS C3C
     LD I,8AE
     LD I,8A8
     LD I,8A8
     LD I,8A8
     LD I,8FF
     SYS 000
     SYS 000
     SYS 000
     SYS 000
     SYS 000
6FE: SYS 000
     SYS 000
     SYS 000
</pre></td></tr>


<tr class="ex"><td class="ex" valign="top"><pre class="exhex" id="Invaders Hex (not working yet)">
 12 25 53 50 41 43 45 20 49 4e 56 41 44 45 52 53
 20 76 30 2e 39 20 42 79 20 44 61 76 69 64 20 57
 49 4e 54 45 52 60 00 61 00 62 08 a3 d3 d0 18 71
 08 f2 1e 31 20 12 2d 70 08 61 00 30 40 12 2d 69
 05 6c 15 6e 00 23 87 60 0a f0 15 f0 07 30 00 12
 4b 23 87 7e 01 12 45 66 00 68 1c 69 00 6a 04 6b
 0a 6c 04 6d 3c 6e 0f 00 e0 23 6b 23 47 fd 15 60
 04 e0 9e 12 7d 23 6b 38 00 78 ff 23 6b 60 06 e0
 9e 12 8b 23 6b 38 39 78 01 23 6b 36 00 12 9f 60
 05 e0 9e 12 e9 66 01 65 1b 84 80 a3 cf d4 51 a3
 cf d4 51 75 ff 35 ff 12 ad 66 00 12 e9 d4 51 3f
 01 12 e9 d4 51 66 00 83 40 73 03 83 b5 62 f8 83
 22 62 08 33 00 12 c9 23 73 82 06 43 08 12 d3 33
 10 12 d5 23 73 82 06 33 18 12 dd 23 73 82 06 43
 20 12 e7 33 28 12 e9 23 73 3e 00 13 07 79 06 49
 18 69 00 6a 04 6b 0a 6c 04 7d f4 6e 0f 00 e0 23
 47 23 6b fd 15 12 6f f7 07 37 00 12 6f fd 15 23
 47 8b a4 3b 12 13 1b 7c 02 6a fc 3b 02 13 23 7c
 02 6a 04 23 47 3c 18 12 6f 00 e0 a4 d3 60 14 61
 08 62 0f d0 1f 70 08 f2 1e 30 2c 13 33 f0 0a 00
 e0 a6 f4 fe 65 12 25 a3 b7 f9 1e 61 08 23 5f 81
 06 23 5f 81 06 23 5f 81 06 23 5f 7b d0 00 ee 80
 e0 80 12 30 00 db c6 7b 0c 00 ee a3 cf 60 1c d8
 04 00 ee 23 47 8e 23 23 47 60 05 f0 18 f0 15 f0
 07 30 00 13 7f 00 ee 6a 00 8d e0 6b 04 e9 a1 12
 57 a6 02 fd 1e f0 65 30 ff 13 a5 6a 00 6b 04 6d
 01 6e 01 13 8d a5 00 f0 1e db c6 7b 08 7d 01 7a
 01 3a 07 13 8d 00 ee 3c 7e ff ff 99 99 7e ff ff
 24 24 e7 7e ff 3c 3c 7e db 81 42 3c 7e ff db 10
 38 7c fe 00 00 7f 00 3f 00 7f 00 00 00 01 01 01
 03 03 03 03 00 00 3f 20 20 20 20 20 20 20 20 3f
 08 08 ff 00 00 fe 00 fc 00 fe 00 00 00 7e 42 42
 62 62 62 62 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 7d 00 41 7d 05 7d 7d 00 00 c2 c2 c6
 44 6c 28 38 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 f7 10 14 f7 f7 04 04 00 00 7c 44 fe
 c2 c2 c2 c2 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 ef 20 28 e8 e8 2f 2f 00 00 f9 85 c5
 c5 c5 c5 f9 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 be 00 20 30 20 be be 00 00 f7 04 e7
 85 85 84 f4 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 00 7f 00 3f 00 7f 00 00 00 ef 28 ef
 00 e0 60 6f 00 00 ff 00 00 00 00 00 00 00 00 ff
 00 00 ff 00 00 fe 00 fc 00 fe 00 00 00 c0 00 c0
 c0 c0 c0 c0 00 00 fc 04 04 04 04 04 04 04 04 fc
 10 10 ff f9 81 b9 8b 9a 9a fa 00 fa 8a 9a 9a 9b
 99 f8 e6 25 25 f4 34 34 34 00 17 14 34 37 36 26
 c7 df 50 50 5c d8 d8 df 00 df 11 1f 12 1b 19 d9
 7c 44 fe 86 86 86 fc 84 fe 82 82 fe fe 80 c0 c0
 c0 fe fc 82 c2 c2 c2 fc fe 80 f8 c0 c0 fe fe 80
 f0 c0 c0 c0 fe 80 be 86 86 fe 86 86 fe 86 86 86
 10 10 10 10 10 10 18 18 18 48 48 78 9c 90 b0 c0
 b0 9c 80 80 c0 c0 c0 fe ee 92 92 86 86 86 fe 82
 86 86 86 86 7c 82 86 86 86 7c fe 82 fe c0 c0 c0
 7c 82 c2 ca c4 7a fe 86 fe 90 9c 84 fe c0 fe 02
 02 fe fe 10 30 30 30 30 82 82 c2 c2 c2 fe 82 82
 82 ee 38 10 86 86 96 92 92 ee 82 44 38 38 44 82
 82 82 fe 30 30 30 fe 02 1e f0 80 fe 00 00 00 00
 06 06 00 00 00 60 60 c0 00 00 00 00 00 00 18 18
 18 18 00 18 7c c6 0c 18 00 18 00 00 fe fe 00 00
 fe 82 86 86 86 fe 08 08 08 18 18 18 fe 02 fe c0
 c0 fe fe 02 1e 06 06 fe 84 c4 c4 fe 04 04 fe 80
 fe 06 06 fe c0 c0 c0 fe 82 fe fe 02 02 06 06 06
 7c 44 fe 86 86 fe fe 82 fe 06 06 06 44 fe 44 44
 fe 44 a8 a8 a8 a8 a8 a8 a8 6c 5a 00 0c 18 a8 30
 4e 7e 00 12 18 66 6c a8 5a 66 54 24 66 00 48 48
 18 12 a8 06 90 a8 12 00 7e 30 12 a8 84 30 4e 72
 18 66 a8 a8 a8 a8 a8 a8 90 54 78 a8 48 78 6c 72
 a8 12 18 6c 72 66 54 90 a8 72 2a 18 a8 30 4e 7e
 00 12 18 66 6c a8 72 54 a8 5a 66 18 7e 18 4e 72
 a8 72 2a 18 30 66 a8 30 4e 7e 00 6c 30 54 4e 9c
 a8 a8 a8 a8 a8 a8 a8 48 54 7e 18 a8 90 54 78 66
 a8 6c 2a 30 5a a8 84 30 72 2a a8 d8 a8 00 4e 12
 a8 e4 a2 a8 00 4e 12 a8 6c 2a 54 54 72 a8 84 30
 72 2a a8 de 9c a8 72 2a 18 a8 0c 54 48 5a 78 72
 18 66 a8 72 18 42 42 6c a8 72 2a 00 72 a8 72 2a
 18 a8 30 4e 7e 00 12 18 66 6c a8 30 4e 0c 66 18
 00 6c 18 a8 72 2a 18 30 66 a8 1e 54 66 0c 18 9c
 a8 24 54 54 12 a8 42 78 0c 3c a8 ae a8 a8 a8 a8
 a8 a8 a8 ff 00 00 00 00 00 00 00 00 00 00 00 00
 00 00 00
</pre></td></tr>


</table>
</td></tr>
</table>

</center>

<hr/>

</div>


</body>

</html>

