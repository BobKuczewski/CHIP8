<!DOCTYPE html>
<html>

<head>
<title>CHIP-8 Simulator</title>
<meta charset="utf-8"/>
</head>

<style>
table.reg,table.mem {
  font-size: 100%;
  border: 1px solid black;
  border-collapse: collapse;
  /* border-spacing: 0px; */
}
tr.reg,tr.mem {
  font-size: 100%;
  background-color: #000000;
  border: none;
  padding: 0px;
  margin: 0px;
}
td.reg,td.mem {
  font-size: 70%;
  background-color: #ffffff;
  border: 1px solid black;
  padding: 0px;
  padding-left: 4px;
  padding-right: 4px;
  margin: 0px;
  text-align: center;
  /*outline-width: 0px;*/
}
input.reg,input.mem {
  font-size: 100%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: right;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 8px;
  /*outline-width: 0px;*/
}
input.regleft {
  font-size: 100%;
  font-family: "Lucida Console", "Courier New", monospace;
  text-align: left;
  background-color: #ffffff;
  border: none;
  padding: 0px;
  margin: 0px;
  height: 8px;
  /*outline-width: 0px;*/
}
</style>

<script>

mem = [];
mem_top = 0x0200;
V = [];
PC = 0x0200;
I = 0x0000;
num_rows = 32;
num_cols = 64;
screen = [];

function replaceAll ( s, t, r ) {
	new_s = (s + " ").trim();
	do {
		last_s = (new_s + " ").trim();
	  new_s = last_s.replace(t,r);
	} while ( ! (new_s === last_s) );
	return ( new_s );
}

function pad0 (val, n) {
  v = val;
  while (v.length < n) {
    v = "0" + v;
  }
  return ( v );
}

function hex (val) {
	return ( val.toString(16).toUpperCase() );
}

function draw_screen() {
  da = document.getElementById ("drawing_area");
  ctxt = da.getContext('2d');
  ctxt.fillStyle = 'black';
  ctxt.fillRect(0, 0, da.width, da.height);
  ctxt.fillStyle = 'white';
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      if (screen[r][c] != 0) {
	      ctxt.fillRect(5*c, 5*r, 5, 5);
	    }
    }
  }
}

function update_display() {
  // Show the Memory starting with mem_top (even addresses)
  base_addr = 2 * Math.floor(mem_top/2);
  for (i=0; i<16; i++) {
    i_text = i.toString(16).toUpperCase().trim();
    addr = base_addr + (2*i);
    document.getElementById("A"+i_text).innerHTML = pad0 ( addr.toString(16).toUpperCase(), 4 );
    mem_val = (mem[addr] << 8) + mem[addr+1];
    document.getElementById("M"+i_text).value = pad0 ( mem_val.toString(16).toUpperCase(), 4 );

    // Initialize the register values
    a = "V" + i_text;
    document.getElementById(a).value = pad0 ( V[i].toString(16).toUpperCase(), 2 );
  }
  document.getElementById("PC").value = pad0 ( PC.toString(16).toUpperCase(), 4 );
  opcode = pad0(mem[PC].toString(16).toUpperCase(),2) + pad0(mem[PC+1].toString(16).toUpperCase(),2)
  document.getElementById("PCINST").value = disassemble_line( opcode.trim() );
  document.getElementById("[I]").value = pad0 ( I.toString(16).toUpperCase(), 4 );
}

function init_machine() {
  // Initialize the memory
  mem = [];
  for (i=0; i<0x10000; i++) {
    mem.push(0xff);
  }
  // Initialize the "V" registers
  V = [];
  for (i=0; i<16; i++) {
    V.push(0);
  }
  // Initialize the display memory
  screen = [];
  for (r=0; r<32; r++) {
    row = [];
    for (c=0; c<64; c++) {
      // row.push((r+c)%2);
      row.push(0);
    }
    screen.push(row)
  }
  update_display();
  draw_screen();
}

function onload() {
  // console.log ("Page loaded");
  // Initialize the drawing area
  da = document.getElementById ("drawing_area");
  ctxt = da.getContext('2d');
  ctxt.fillStyle = 'black';
  ctxt.fillRect(0, 0, da.width, da.height);
  init_machine();
}

function changed_format() {
  // fmt = document.getElementById ("format_to").value;
  // console.log ("Format changed to " + fmt);
}

function get_b_comma_vx ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1);
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_b ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2);
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_vy ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_vy (" + s + ") = " + result );
  return ( result );
}

function assemble() {
  // console.log ("Assemble code");
  srctxt = document.getElementById ( "source" ).value;
  // console.log ( "Text = " + srctxt );

  // Normalize line endings and remove empty lines
	text = replaceAll( srctxt, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	// console.log ( text );
	// Convert all white space to spaces
	// text = text.replace(/\s+/g,' ');
  // Remove all double spaces
	while (text.indexOf("  ") >= 0) {
		text = replaceAll(text, "  ", " ");
	}
	// console.log ( text );
	// Split the text into an array of lines
  lines = text.split("\n");
	// console.log ( "lines=" + lines );

  // Remove all comments and empty lines
  new_lines = [];
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
	  if (line.indexOf(";") >= 0) {
			// Remove the comment
			line = line.substr(0,line.indexOf(";")).trim();
	  }
	  if (line.trim().length > 0) {
			new_lines.push ( line.trim() );
	  }
	}
	lines = new_lines;

  // Compute the label addresses
  label_dict = {};
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
	  if (line.indexOf(":") >= 0) {
	    // Store the label and its location
	    label = line.substr(0,line.indexOf(":"));
	    label_dict[label] = ((2*l)+0x200).toString(16);
	    while (label_dict[label].length < 3) {
	      label_dict[label] = '0' + label_dict[label];
	    }
	    // Remove the label from the line of code for assembly
	    lines[l] = lines[l].substr(line.indexOf(":")+1).trim();
	  }
	}
	keys = Object.keys(label_dict);
	// console.log ( "labels = " + keys );
	for (l=0; l<lines.length; l++) {
	  for (ki=0; ki<keys.length; ki++) {
	    // console.log ( "Searching for " + keys[ki] );
      lines[l] = replaceAll( lines[l].toUpperCase(), keys[ki], label_dict[keys[ki]]);
	  }
	}

  // Clear the machine code window
  mcwin = document.getElementById ( "machine" );
  mcwin.value = "";
	// Process the lines one by one
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
		// line = lines[l].replace(/\s+/g,''); // Remove all white space
	  if (line.indexOf(";") >= 0) {
			// Remove the comment
			line = line.substr(0,line.indexOf(";")).trim();
	  }
	  if (line.length > 0) {
		  if (line.indexOf(":") >= 0) {
				// Throw away the labels for now
				line = line.substr(line.indexOf(":")+1).trim();
		  }
		  if (line.slice(0,5) == "DATA ") {
				mcwin.value += line.slice(5).trim() + "\n";
		  } else if (line.slice(0,4) == "SYS ") {
				mcwin.value += "0" + line.slice(4).trim() + "\n";
		  } else if (line.slice(0,3) == "CLS") {
				mcwin.value += "00E0\n";
		  } else if (line.slice(0,3) == "RET") {
				mcwin.value += "00EE\n";
		  } else if (line.slice(0,3) == "JP ") {
				// JP can take the following forms:
				//   JP nnn    -->  1nnn
				//   JP V0,nnn -->  Bnnn
				if (line.indexOf(",") >= 0) {
					mcwin.value += "B" + line.slice(line.indexOf(",")+1).trim() + "\n";
			  } else {
					mcwin.value += "1" + line.slice(2).trim() + "\n";
			  }
		  } else if (line.slice(0,5) == "CALL ") {
				// CALL takes the following form:
				//   CALL nnn
				mcwin.value += "2" + line.slice(5).trim() + "\n";
		  } else if (line.slice(0,3) == "SE ") {
				// SE (Skip when Equal) can take the following forms:
				//   SE Vx,byte -> 3xbb
				//   SE Vx,Vy   -> 5xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SE Vx,byte -> 3xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					mcwin.value += "3" + vb[0] + vb[1] + "\n";
				} else {
					// SE Vx,Vy   -> 5xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					mcwin.value += "5" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,4) == "SNE ") {
				// SNE (Skip when Not Equal) can take the following forms:
				//   SNE Vx,byte -> 4xbb
				//   SNE Vx,Vy   -> 9xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SNE Vx,byte -> 4xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					mcwin.value += "4" + vb[0] + vb[1] + "\n";
				} else {
					// SNE Vx,Vy   -> 9xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					mcwin.value += "9" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,3) == "LD ") {
				// LD (Load) can take the following forms:
				//   LD Vx,byte -> 6xbb
				//   LD Vx,Vy   -> 8xy0
				//   LD I,nnn   -> Annn
				//   LD Vx,DT   -> Fx07
				//   LD Vx,K    -> Fx0A
				//   LD DT,Vx   -> Fx15
				//   LD ST,Vx   -> Fx18
				//   LD F,Vx    -> Fx29
				//   LD B,Vx    -> Fx33
				//   LD [I],Vx  -> Fx55
				//   LD Vx,[I]  -> Fx65
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				// Handle the easy ones first
				if (pars[0] == "I") {
				  // LD I,nnn   -> Annn
					mcwin.value += "A" + pars[1].trim() + "\n";
				} else if (pars[0] == "DT") {
				  // LD DT,Vx   -> Fx15
					mcwin.value += "F" + pars[1].slice(1).trim() + "15\n";
				} else if (pars[0] == "ST") {
					// LD ST,Vx   -> Fx18
					mcwin.value += "F" + pars[1].slice(1).trim() + "18\n";
				} else if (pars[0] == "F") {
					// LD F,Vx    -> Fx29
					mcwin.value += "F" + pars[1].slice(1).trim() + "29\n";
				} else if (pars[0] == "B") {
					// LD B,Vx    -> Fx33
					mcwin.value += "F" + pars[1].slice(1).trim() + "33\n";
				} else if (pars[0] == "[I]") {
					// LD [I],Vx  -> Fx55
					mcwin.value += "F" + pars[1].slice(1).trim() + "55\n";
				} else if (pars[1] == "DT") {
				  // LD Vx,DT   -> Fx07
					mcwin.value += "F" + pars[0].slice(1).trim() + "07\n";
				} else if (pars[1] == "K") {
				  // LD Vx,K    -> Fx0A
				} else if (pars[1] == "[I]") {
					// LD Vx,[I]  -> Fx65
					mcwin.value += "F" + pars[0].slice(1).trim() + "65\n";
				} else {
				  if (line.split(",")[1].indexOf("V") < 0) {
						// LD Vx,byte -> 6xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  mcwin.value += "6" + vb[0] + vb[1] + "\n";
				  } else {
						// LD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
						mcwin.value += "8" + vv[0] + vv[1] + "0" + "\n";
					}
				}
		  } else if (line.slice(0,4) == "ADD ") {
				// ADD can take the following forms:
				//   ADD Vx,byte -> 7xbb
				//   ADD Vx,Vy   -> 8xy4
				//   ADD I,Vx    -> Fx1E
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				if (pars[0] == "I") {
				  // ADD I,Vx    -> Fx1E
					mcwin.value += "F" + pars[1].slice(1).trim() + "1E\n";
			  } else {
				  if (pars[1].indexOf("V") < 0) {
						// ADD Vx,byte -> 7xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  mcwin.value += "7" + vb[0] + vb[1] + "\n";
				  } else {
				  	// ADD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
					  mcwin.value += "8" + vv[0] + vv[1] + "4" + "\n";
					}
			  }
		  } else if (line.slice(0,3) == "OR ") {
				vv = get_vx_comma_vy ( line.slice(2).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "1" + "\n";
		  } else if (line.slice(0,4) == "AND ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "2" + "\n";
		  } else if (line.slice(0,4) == "XOR ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "3" + "\n";
		  } else if (line.slice(0,4) == "SUB ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "5" + "\n";
		  } else if (line.slice(0,4) == "SHR ") {
				if (line.indexOf(",") >= 0) {
				  // SHR Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHR Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  mcwin.value += "8" + vv[0] + vv[1] + "6" + "\n";
		  } else if (line.slice(0,5) == "SUBN ") {
				vv = get_vx_comma_vy ( line.slice(4).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "7" + "\n";
		  } else if (line.slice(0,4) == "SHL ") {
				if (line.indexOf(",") >= 0) {
				  // SHL Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHL Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  mcwin.value += "8" + vv[0] + vv[1] + "E" + "\n";
		  } else if (line.slice(0,4) == "RND ") {
				vb = get_vx_comma_b ( line.slice(3) );
			  mcwin.value += "C" + vb[0] + vb[1] + "\n";
		  } else if (line.slice(0,4) == "DRW ") {
		  	pars = line.slice(3).split(",");
		  	pars[0] = pars[0].trim();
		  	pars[1] = pars[1].trim();
		  	pars[2] = pars[2].trim();
			  mcwin.value += "D" + pars[0][1] + pars[1][1] + pars[2][0] + "\n";
		  } else if (line.slice(0,4) == "SKP ") {
		  	vx = line.slice(3).trim();
			  mcwin.value += "E" + vx[1] + "9E" + "\n";
		  } else if (line.slice(0,5) == "SKNP ") {
		  	vx = line.slice(4).trim();
			  mcwin.value += "E" + vx[1] + "A1" + "\n";
		  } else {
				mcwin.value += "[??]" + line + "\n";
		  }
		}
  }
}

function get_machine_lines ( text_in ) {
  // Normalize line endings and remove empty lines
	text = replaceAll( text_in, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	// Convert to upper case
	text = "" + text.toUpperCase();
	// Remove all line endings
	while (text.indexOf("\n") >= 0) {
		text = replaceAll(text, "\n", "");
	}
	// Remove all spaces
	while (text.indexOf(" ") >= 0) {
		text = replaceAll(text, " ", "");
	}
	// Split by 4 digits per instruction
  lines = [];
  while (text.length > 0) {
		lines.push ( text.slice(0,4) );
		text = text.slice(4)
  }
  return ( lines );
}

function disassemble_line ( line ) {

  result = "";

	// #### : 00E0 00EE
  if (line == "00E0") {
	  result += "CLS";
	} else if (line == "00EE") {
	  result += "RET";

	// #nnn : 0 1 2 A B
	} else if (line[0] == "0") {
	  result += "SYS " + line.slice(1);
	} else if (line[0] == "1") {
	  // result += "JP L" + line.slice(1);
	  result += "JP " + line.slice(1);
	} else if (line[0] == "2") {
	  // result += "CALL L" + line.slice(1);
	  result += "CALL " + line.slice(1);
	} else if (line[0] == "A") {
	  result += "LD I," + line.slice(1);
	} else if (line[0] == "B") {
	  result += "JP V0," + line.slice(1);

	// #nkk or #xkk : 3 4 6 7 C
	} else if (line[0] == "3") {
	  result += "SE V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "4") {
	  result += "SNE V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "6") {
	  result += "LD V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "7") {
	  result += "ADD V" + line[1] + "," + line.slice(2);
	} else if (line[0] == "C") {
	  result += "RND V" + line[1] + "," + line.slice(2);

	// #xy# : 5, 8, 9, D
	} else if (line[0] == "5") {
	  if (line[3] == "0") {
		  result += "SE V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "8") {
	  if (line[3] == "0") {
		  result += "LD V" + line[1] + ",V" + line[2];
		} else if (line[3] == "1") {
		  result += "OR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "2") {
		  result += "AND V" + line[1] + ",V" + line[2];
		} else if (line[3] == "3") {
		  result += "XOR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "4") {
		  result += "ADD V" + line[1] + ",V" + line[2];
		} else if (line[3] == "5") {
		  result += "SUB V" + line[1] + ",V" + line[2];
		} else if (line[3] == "6") {
		  result += "SHR V" + line[1] + ",V" + line[2];
		} else if (line[3] == "7") {
		  result += "SUBN V" + line[1] + ",V" + line[2];
		} else if (line[3] == "E") {
		  result += "SHL V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "9") {
	  if (line[3] == "0") {
		  result += "SNE V" + line[1] + ",V" + line[2];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "D") {
	  result += "DRW V" + line[1] + ",V" + line[2] + "," + line[3];

	// #x## : E, F
	} else if (line[0] == "E") {
	  if (line.slice(2) == "9E") {
		  result += "SKP V" + line[1];
	  } else if (line.slice(2) == "A1") {
		  result += "SKNP V" + line[1];
		} else {
		  result += "DATA " + line;
		}
	} else if (line[0] == "F") {
	  if (line.slice(2) == "07") {
		  result += "LD V" + line[1] + ",DT";
	  } else if (line.slice(2) == "0A") {
		  result += "LD V" + line[1] + ",K";
	  } else if (line.slice(2) == "15") {
		  result += "LD DT,V" + line[1];
	  } else if (line.slice(2) == "18") {
		  result += "LD ST,V" + line[1];
	  } else if (line.slice(2) == "1E") {
		  result += "ADD I,V" + line[1];
	  } else if (line.slice(2) == "29") {
		  result += "LD F,V" + line[1];
	  } else if (line.slice(2) == "33") {
		  result += "LD B,V" + line[1];
	  } else if (line.slice(2) == "55") {
		  result += "LD [I],V" + line[1];
	  } else if (line.slice(2) == "65") {
		  result += "LD V" + line[1] + ",[I]";
		} else {
		  result += "DATA " + line;
		}

	// Unknown
	} else {
	  result += "DATA " + line;
	}

  return ( result );
}


function disassemble() {
  // console.log ("Disassemble code");
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines
	lines = get_machine_lines ( bintxt );
  // console.log ( "Text = " + bintxt );
  opts = document.getElementById ( "disassem_opts" ).value;
  // console.log ( "Disassemble with options: " + opts );
  // Clear the source window
  document.getElementById ( "source" ).value = "";
	// Process the lines one by one
	for (l=0; l<lines.length; l++) {
		if (opts.indexOf("L") >= 0) {
		  // document.getElementById ( "source" ).value += "L"+((l*2)+0x200).toString(16).toUpperCase() + ": ";
		  document.getElementById ( "source" ).value += ((l*2)+0x200).toString(16).toUpperCase() + ": ";
		}
		if (opts.indexOf("H") >= 0) {
		  document.getElementById ( "source" ).value += lines[l] + "  ";
		}
    document.getElementById ( "source" ).value += disassemble_line ( lines[l] ) + "\n";
  }
}

saved_text = "";
function save() {
  saved_text = document.getElementById ( "source" ).value;
}

function restore() {
  document.getElementById ( "source" ).value = saved_text;
}

function load() {
  // Load from the machine code text area into mem
  bintxt = document.getElementById ( "machine" ).value;
  // Convert the text into lines of instructions
	lines = get_machine_lines ( bintxt );
  addr = 0x0200;
	for (i=0; i<lines.length; i++) {
	  mem[addr++] = parseInt ( lines[i].slice(0,2), 16 );
	  mem[addr++] = parseInt ( lines[i].slice(2,4), 16 );
	}
	update_display();
}

function reset() {
  PC = 0x0200;
  I  = 0x0000;
	for (i=0; i<16; i++) {
	  V[i] = 0;
	}
  for (r=0; r<num_rows; r++) {
    for (c=0; c<num_cols; c++) {
      screen[r][c] = 0;
    }
  }
	draw_screen();
	update_display();
}

function step1() {
  // Could not use the name "step" for some reason?
  instruction = (mem[PC] << 8) + mem[PC+1];
  console.log ( "Execute " + pad0(instruction.toString(16).toUpperCase(),4) );
  if (instruction == 0x00E0) { // CLS
    console.log ( "CLS" );
	  PC = PC + 2;
  } else if (instruction == 0x00EE) { // RET
    console.log ( "RET" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x1000) {  // JP NNN
    console.log ( "JP" );
    PC = instruction & 0xFFF;
  } else if ( (instruction & 0xF000) == 0x2000) { // CALL NNN
    console.log ( "CALL" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x3000) { // SE Vx,byte
    console.log ( "SE Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    if ( V[(instruction&0x0F00)>>8] == (instruction&0x00FF) ) {
		  PC = PC + 4;
		} else {
		  PC = PC + 2;
		}
  } else if ( (instruction & 0xF000) == 0x4000) { // SNE Vx,byte
    console.log ( "SNE - Skip if Not Equal immediate" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x5000) { // SE Vx,Vy
    console.log ( "SE - Skip if Equal Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x6000) { // LD Vx,byte
    console.log ( "LD immediate with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = instruction&0x00FF;
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0x7000) { // ADD Vx,byte
    console.log ( "ADD immediate === Add Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    x = (instruction&0x0F00)>>8;
    V[x] = V[x] + (instruction&0x00FF);
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8000) { // LD Vx,Vy
    console.log ( "LD Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8001) { // OR Vx,Vy
    console.log ( "OR Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8002) { // AND Vx,Vy
    console.log ( "AND Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8003) { // XOR Vx,Vy
    console.log ( "XOR Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8004) { // ADD Vx,Vy
    console.log ( "ADD Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8005) { // SUB Vx,Vy
    console.log ( "SUB Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8006) { // SHR Vx,Vy
    console.log ( "SHR" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x8007) { // SUBN Vx,Vy
    console.log ( "SUBN" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x800E) { // SHL Vx,Vy
    console.log ( "SHL" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF00F) == 0x9000) { // SNE Vx,Vy
    console.log ( "SNE - Skip if Not Equal Reg" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xA000) { // I = NNN
    console.log ( "LD I, addr" );
    I = instruction & 0xFFF;
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xB000) { // JP V0,NNN
    console.log ( "JP V0, addr" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xC000) { // RND Vx,byte
		console.log ( "RND Vx, byte with Vx=" + hex((instruction&0x0F00)>>8) + ", byte=" + hex(instruction&0x00FF) );
    V[(instruction&0x0F00)>>8] = Math.floor(Math.random() * 256) & (instruction&0x00FF);
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xD000) { // DRW Vx,Vy,n
    // Draw a sprite at Vx,Vy of size nx8 from bytes at [I]
    vx = ( instruction & 0x0F00 ) >> 8;
    vy = ( instruction & 0x00F0 ) >> 4;
    n = instruction & 0x000F;
    for (pixrow=0; pixrow<n; pixrow++) {
      for (c=0; c<8; c++) {
        if ( mem[I+pixrow] & (0x80 >> c) ) {
			    screen[(V[vy]+pixrow)%num_rows][(V[vx]+c)%num_cols] = 1;
			  }
			}
    }
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xE09E) { // SKP Vx (Skip Key Vx is Pressed
    console.log ( "SKP Vx" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF000) == 0xE0A1) { // SKNP Vx (Skip Key Vx is Not Pressed
    console.log ( "SKNP Vx" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF007) { // LD Vx, DT
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF00A) { // LD Vx, K
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF015) { // LD DT, Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF018) { // LD ST, Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF01E) { // ADD I, Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF029) { // LD F, Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF033) { // LD B, Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF055) { // LD [I], Vx
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else if ( (instruction & 0xF0FF) == 0xF065) { // LD Vx, [I]
    console.log ( "LD Vx,DT" );
	  PC = PC + 2;
  } else {
    console.log ( "UNKNOWN INSTRUCTION: " + pad0(instruction.toString(16).toUpperCase(),4) );
	  PC = PC + 2;
  }
	update_display();
	draw_screen();
}

function run() {
	for (stepnum=0; stepnum<1000; stepnum++) {
		step1();
	}
}

function stop() {
}

</script>

<body bgcolor="lightblue" onload="onload()">
<center>

<span id="title"><b>CHIP-8 Simulator</b></span>
<p/>
<center>
<table>
	<tr>
	  <!--
		<td>
			<select id="assem_opts" onchange="changed_format()">
			<option value="H" selected>Plain Hex</option>
			<option value="I">Intel Hex</option>
			</select>
		</td>
		-->
		<td>
			<input type="button" name="assem" value="Assemble" onclick="assemble();"></input>
		</td>
		<td>
			<input type="button" name="save" value="Save" onclick="save();"></input>
		</td>
		<td>
			<input type="button" name="restore" value="Restore" onclick="restore();"></input>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp; 
		  <input type="button" name="disassem" value="Disassemble as" onclick="disassemble();"></input>
		</td>
		<td>
			<select id="disassem_opts" onchange="changed_format()">
			<option value="S">Src</option>
			<option value="LS" selected>L+S</option> -->
			<option value="HS">H+S</option> -->
			<option value="LHS">LHS</option> -->
			</select>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp;
			<input type="button" name="load"  value="Load"  onclick="load();"></input>
			<input type="button" name="reset"  value="Reset"  onclick="reset();"></input>
		</td>
		<td>
		  &nbsp; &nbsp; &nbsp; &nbsp;
			<input type="button" name="step1" value="Step" onclick="step1();"></input>
			<input type="button" name="run"  value="Run"  onclick="run();"></input>
			<input type="button" name="stop" value="Stop" onclick="stop();"></input>
		</td>
	</tr>
</table>
<center>
<table width="100%" style="padding:10px; border-spacing:2px; border:4px solid black; background-color:#dddddd; text-align:left; font-family: Arial, Helvetica, sans-serif; font-size: 14px;" >
  <colgroup>
		<col>
		<col>
  </colgroup>
  <thead>
		<tr>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Source Code</th>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Machine Code</th>
		  <th style="text-align:center; padding:5px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Chip-8 Virtual Machine</th>
		</tr>
  </thead>
	<tbody>
  	<tr>
		  <td valign="top">
				<center>
				<textarea id="source" rows="27" cols="50"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false">
;===========================;
; Generate a maze in CHIP-8 ;
;===========================;
; Registers:                ;
;   V0 used for x           ;
;   V1 used for y           ;
;   V2 used for random bit  ;
;===========================;

TOP: LD I,R3      ; Load sprite address
     RND V2,01    ; Put random bit in V2
     SE V2,01     ; Skip if V2=1 (random)
     LD I,R1      ; Load a different sprite
     DRW V0,V1,4  ; Draw at (V0,V1) 4 rows
     ADD V0,04    ; Add 4 to x coord
     SE V0,40     ; Skip if at end of V0
     JP TOP       ; Go back to top
     LD V0,00     ; At end so go back x=0
     ADD V1,04    ; Add 4 to y
     SE V1,20     ; Skip if end of y (done)
     JP TOP       ; Go back to top
END: JP END       ; Stay here ... forever

R1:  DATA 8040    ; Image data
R2:  DATA 2010    ; Image data
R3:  DATA 2040    ; Image data
R4:  DATA 8010    ; Image data</textarea>

				</center>
			</td>

		  <td valign="top">
				<center>
				<!-- Generate hex from binary ch8 file with: od -v -tx1 -An filename -->

				<!-- $ od -v -tx1 -An bin/chip8/games/Maze.ch8
							 a2 1e c2 01 32 01 a2 1a d0 14 70 04 30 40 12 00
							 60 00 71 04 31 20 12 00 12 18 80 40 20 10 20 40
							 80 10 -->

				<textarea id="machine" rows="27" cols="5"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false"></textarea>
<!--
A21E
C201
3201
A21A
D014
7004
3040
1200
6000
7104
3120
1200
1218
8040
2010
2040
8010
</textarea> -->
				</center>
			</td>

		  <td valign="top"> <!-- Start of VIRTUAL MACHINE -->
		    <center>
		    <table>
		    <tr><td>
				<center>
					<!--div id="tdiv" style="resize: both; overflow: auto;"--> 
					<div id="tdiv">
					<center>
					<canvas id="drawing_area" width="320" height="160"
						style="margin:2px; padding:2px; border:2px solid #cccccc; resize: both; overflow: auto;"> 
						<!-- Use: style="margin:2px; padding:2px; border:2px solid #cccccc; display:none;" -->
						Your browser does not support the HTML5 canvas tag.
					</canvas>
					</center>
					</div>
				</center>
				</td></tr>
		    <tr><td>
				<center>
				<table> <!-- Start of Virtual Machine Controls -->
					<tr>
					<!-- Memory Controls -->
					<td>
					<center>
					  <input type="button" name="memup"  value="⇧"  onclick="mem_top = 0x0000; update_display();"></input></br>
					  <input type="button" name="memup"  value="↟"  onclick="mem_top = Math.max(0,mem_top-16); update_display();"></input></br>
					  <input type="button" name="memup"  value="↑"  onclick="mem_top = Math.max(0,mem_top-2); update_display();"></input></br>
					  <input type="button" name="memup"  value="⌂"  onclick="mem_top = 0x0200; update_display();"></input></br>
					  <input type="button" name="memdn"  value="↓"  onclick="mem_top = Math.min(0xffe0,mem_top+2); update_display();"></input></br>
					  <input type="button" name="memdn"  value="⇓"  onclick="mem_top = Math.min(0xffe0,mem_top+16); update_display();"></input></br>
					  <input type="button" name="memdn"  value="⇩"  onclick="mem_top = 0xffe0; update_display();"></input></br>
					</center>
					</td>
					<!-- Memory table -->
					<td style="vertical-align: top;">
						<table class="mem">
							<tr class="mem"><td class="mem" id="A0"></td><td class="mem"><input type="text" id="M0" class="mem" name="M0" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A1"></td><td class="mem"><input type="text" id="M1" class="mem" name="M1" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A2"></td><td class="mem"><input type="text" id="M2" class="mem" name="M2" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A3"></td><td class="mem"><input type="text" id="M3" class="mem" name="M3" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A4"></td><td class="mem"><input type="text" id="M4" class="mem" name="M4" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A5"></td><td class="mem"><input type="text" id="M5" class="mem" name="M5" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A6"></td><td class="mem"><input type="text" id="M6" class="mem" name="M6" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A7"></td><td class="mem"><input type="text" id="M7" class="mem" name="M7" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A8"></td><td class="mem"><input type="text" id="M8" class="mem" name="M8" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="A9"></td><td class="mem"><input type="text" id="M9" class="mem" name="M9" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AA"></td><td class="mem"><input type="text" id="MA" class="mem" name="MA" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AB"></td><td class="mem"><input type="text" id="MB" class="mem" name="MB" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AC"></td><td class="mem"><input type="text" id="MC" class="mem" name="MC" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AD"></td><td class="mem"><input type="text" id="MD" class="mem" name="MD" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AE"></td><td class="mem"><input type="text" id="ME" class="mem" name="ME" size="4"></td></tr>
							<tr class="mem"><td class="mem" id="AF"></td><td class="mem"><input type="text" id="MF" class="mem" name="MF" size="4"></td></tr>
						</table>
					</td>
					<!-- Register table -->
					<td style="vertical-align: top;">
						<table class="reg">
							<tr class="reg"><td class="reg">V0</td><td class="reg"><input type="text" id="V0" class="reg" name="V0" size="2"></td></tr>
							<tr class="reg"><td class="reg">V1</td><td class="reg"><input type="text" id="V1" class="reg" name="V1" size="2"></td></tr>
							<tr class="reg"><td class="reg">V2</td><td class="reg"><input type="text" id="V2" class="reg" name="V2" size="2"></td></tr>
							<tr class="reg"><td class="reg">V3</td><td class="reg"><input type="text" id="V3" class="reg" name="V3" size="2"></td></tr>
							<tr class="reg"><td class="reg">V4</td><td class="reg"><input type="text" id="V4" class="reg" name="V4" size="2"></td></tr>
							<tr class="reg"><td class="reg">V5</td><td class="reg"><input type="text" id="V5" class="reg" name="V5" size="2"></td></tr>
							<tr class="reg"><td class="reg">V6</td><td class="reg"><input type="text" id="V6" class="reg" name="V6" size="2"></td></tr>
							<tr class="reg"><td class="reg">V7</td><td class="reg"><input type="text" id="V7" class="reg" name="V7" size="2"></td></tr>
							<tr class="reg"><td class="reg">V8</td><td class="reg"><input type="text" id="V8" class="reg" name="V8" size="2"></td></tr>
							<tr class="reg"><td class="reg">V9</td><td class="reg"><input type="text" id="V9" class="reg" name="V9" size="2"></td></tr>
							<tr class="reg"><td class="reg">VA</td><td class="reg"><input type="text" id="VA" class="reg" name="VA" size="2"></td></tr>
							<tr class="reg"><td class="reg">VB</td><td class="reg"><input type="text" id="VB" class="reg" name="VB" size="2"></td></tr>
							<tr class="reg"><td class="reg">VC</td><td class="reg"><input type="text" id="VC" class="reg" name="VC" size="2"></td></tr>
							<tr class="reg"><td class="reg">VD</td><td class="reg"><input type="text" id="VD" class="reg" name="VD" size="2"></td></tr>
							<tr class="reg"><td class="reg">VE</td><td class="reg"><input type="text" id="VE" class="reg" name="VE" size="2"></td></tr>
							<tr class="reg"><td class="reg">VF</td><td class="reg"><input type="text" id="VF" class="reg" name="VF" size="2"></td></tr>
						</table>
					</td>
					<!-- PC and [I] table -->
					<td style="vertical-align: top;">
						<table>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">PC</td><td class="reg"><input type="text" id="PC" class="reg" name="PC" size="4"></td></tr>
									</table>
								</td>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg"><input type="text" id="PCINST" class="regleft" name="PCINST" size="12"></td></tr>
									</table>
								</td>
							</tr>
							<tr>
								<td>
									<table class="reg">
										<tr class="reg"><td class="reg">[ I ]</td><td class="reg"><input type="text" id="[I]" class="reg" name="[I]" size="4"></td></tr>
									</table>
								</td>
							</tr>
						</table>
					</td>
					</tr>
				</table> <!-- End of Virtual Machine Controls -->
				</center>
				</td></tr>
				</table>
		    </center>
			</td>  <!-- End of VIRTUAL MACHINE -->

		</tr>
	</tbody>
</table>




<p/>
=== Assembler Syntax === <!-- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM -->
<table><tr><td>
<tt>
<pre>
Code   Assembly           Description - All numbers are hexadecimal
----   --------           -----------------------------------------
       lbl:               A label - must not match any other string in the program!
nnnn - DATA nnnn          Initialize a data word (all values in hex)

0nnn - SYS addr           Jump to a machine code routine at nnn.
00E0 - CLS                Clear the display.
00EE - RET                Return from a subroutine.
1nnn - JP addr            Jump to location nnn.
2nnn - CALL addr          Call subroutine at nnn.
3xkk - SE Vx, byte        Skip If Equal Immediate: Skip next instruction if Vx = kk.
4xkk - SNE Vx, byte       Skip If Not Equal Immediate: Skip next instruction if Vx != kk.
5xy0 - SE Vx, Vy          Skip If Equal Register: Skip next instruction if Vx = Vy.
6xkk - LD Vx, byte        Load Immediate: Set Vx = kk.
7xkk - ADD Vx, byte       Add Immediate: Set Vx = Vx + kk.
8xy0 - LD Vx, Vy          Load Register: Set Vx = Vy.
8xy1 - OR Vx, Vy          Or Register: Set Vx = Vx OR Vy.
8xy2 - AND Vx, Vy         And Register: Set Vx = Vx AND Vy.
8xy3 - XOR Vx, Vy         XOR Register: Set Vx = Vx XOR Vy.
8xy4 - ADD Vx, Vy         Add Register: Set Vx = Vx + Vy, set VF = carry.
8xy5 - SUB Vx, Vy         Sub Register: Set Vx = Vx - Vy, set VF = NOT borrow.
8xy6 - SHR Vx {, Vy}      Shift Right: Set Vx = Vx SHR 1.
8xy7 - SUBN Vx, Vy        Sub Negative Register: Set Vx = Vy - Vx, set VF = NOT borrow.
8xyE - SHL Vx {, Vy}      Shift Left: Set Vx = Vx SHL 1.
9xy0 - SNE Vx, Vy         Skip If Not Equal: Skip next instruction if Vx != Vy.
Annn - LD I, addr         Load I Immediate: Set I = nnn.
Bnnn - JP V0, addr        Jump to V0 with offset nnn.
Cxkk - RND Vx, byte       Rand: Set Vx to a random number (0 to 255) AND byte value
Dxyn - DRW Vx, Vy, n      Draw: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
Ex9E - SKP Vx             Skip if Key[Vx]: Skip next instruction if key with the value of Vx is pressed.
ExA1 - SKNP Vx            Skip if !Key[Vx]: Skip next instruction if key with the value of Vx is not pressed.
Fx07 - LD Vx, DT          Load Vx from Delay Timer: Set Vx = delay timer value.
Fx0A - LD Vx, K           Load Vx from next Key: Wait for a key press, store the value of the key in Vx.
Fx15 - LD DT, Vx          Load Delay Timer from Vx: Set delay timer = Vx.
Fx18 - LD ST, Vx          Load Sound Timer from Vx: Set sound timer = Vx.
Fx1E - ADD I, Vx          Add Vx to I: Set I = I + Vx.
Fx29 - LD F, Vx           Load I from Sprite location: Set I = location of sprite for digit Vx.
Fx33 - LD B, Vx           Load BCD from X into Memory[I]: Store BCD representation of Vx in memory locations I, I+1, and I+2.
Fx55 - LD [I], Vx         Save Registers: Store registers V0 through Vx in memory starting at location I.
Fx65 - LD Vx, [I]         Restore Register: Read registers V0 through Vx from memory starting at location I.
</pre>
</tt>
</td></tr></table>
<hr/>
</center>

Note: You can convert a binay <b>.ch8</b> file to hex for the Machine Code window with:<br/>
<br/>
$ od -v -tx1 -An filename<br/>
<br/>
For example:<br/>
<br/>
<tt>
$ od -v -tx1 -An bin/chip8/games/Maze.ch8<br/>
a2 1e c2 01 32 01 a2 1a d0 14 70 04 30 40 12 00<br/>
60 00 71 04 31 20 12 00 12 18 80 40 20 10 20 40<br/>
80 10
</tt>

</body>

</html>

