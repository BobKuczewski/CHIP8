<!DOCTYPE html>
<html>

<head>
<title>CHIP-8 Assembler/Disassembler</title>
<meta charset="utf-8"/>
</head>

<style>
.sel {
  FONT-WEIGHT: bold;
	COLOR: #000000;
  BACKGROUND-COLOR: #ffff00;
}
</style>

<script>
function replaceAll ( s, t, r ) {
	new_s = (s + " ").trim();
	do {
		last_s = (new_s + " ").trim();
	  new_s = last_s.replace(t,r);
	} while ( ! (new_s === last_s) );
	return ( new_s );
}

var num_matched = 0;
var full_text = "Four score and seven years ago ...";
var last_index = -1;
var random_sentence = "";

function changed_format() {
  fmt = document.getElementById ("format_to").value;
  // console.log ("Format changed to " + fmt);
}

function onload() {
  // console.log ("Page loaded");
}

function get_b_comma_vx ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1);
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_b ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2);
  // console.log ("get_vx_comma_b (" + s + ") = " + result );
  return ( result );
}

function get_vx_comma_vy ( s ) {
  result = []
  comma = s.indexOf(",");
  p1 = s.slice(0,comma).trim();
  p2 = s.slice(comma+1).trim();
  result.push (p1.slice(1));
  result.push (p2.slice(1));
  // console.log ("get_vx_comma_vy (" + s + ") = " + result );
  return ( result );
}

function assemble() {
  // console.log ("Assemble code");
  srctxt = document.getElementById ( "source" ).value;
  // console.log ( "Text = " + srctxt );

  // Normalize line endings and remove empty lines
	text = replaceAll( srctxt, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	console.log ( text );
	// Convert all white space to spaces
	// text = text.replace(/\s+/g,' ');
  // Remove all double spaces
	while (text.indexOf("  ") >= 0) {
		text = replaceAll(text, "  ", " ");
	}
	console.log ( text );
	// Split the text into an array of lines
  lines = text.split("\n");
	console.log ( "lines=" + lines );
  // Clear the machine code window
  mcwin = document.getElementById ( "machine" );
  mcwin.value = "";
	// Process the lines one by one
	for (l=0; l<lines.length; l++) {
	  line = lines[l].toUpperCase().trim();
		// line = lines[l].replace(/\s+/g,''); // Remove all white space
	  if (line.indexOf(";") >= 0) {
			// Remove the comment
			line = line.substr(0,line.indexOf(";")).trim();
	  }
	  if (line.length > 0) {
		  if (line.indexOf(":") >= 0) {
				// Throw away the labels for now
				line = line.substr(line.indexOf(":")+1).trim();
		  }
		  if (line.slice(0,5) == "DATA ") {
				mcwin.value += line.slice(5).trim() + "\n";
		  } else if (line.slice(0,4) == "SYS ") {
				mcwin.value += "0" + line.slice(4).trim() + "\n";
		  } else if (line.slice(0,3) == "CLS") {
				mcwin.value += "00E0\n";
		  } else if (line.slice(0,3) == "RET") {
				mcwin.value += "00EE\n";
		  } else if (line.slice(0,3) == "JP ") {
				// JP can take the following forms:
				//   JP nnn    -->  1nnn
				//   JP V0,nnn -->  Bnnn
				if (line.indexOf(",") >= 0) {
					mcwin.value += "B" + line.slice(line.indexOf(",")+1).trim() + "\n";
			  } else {
					mcwin.value += "1" + line.slice(2).trim() + "\n";
			  }
		  } else if (line.slice(0,5) == "CALL ") {
				// CALL takes the following form:
				//   CALL nnn
				mcwin.value += "2" + line.slice(5).trim() + "\n";
		  } else if (line.slice(0,3) == "SE ") {
				// SE (Skip when Equal) can take the following forms:
				//   SE Vx,byte -> 3xbb
				//   SE Vx,Vy   -> 5xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SE Vx,byte -> 3xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					mcwin.value += "3" + vb[0] + vb[1] + "\n";
				} else {
					// SE Vx,Vy   -> 5xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					mcwin.value += "5" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,4) == "SNE ") {
				// SNE (Skip when Not Equal) can take the following forms:
				//   SNE Vx,byte -> 4xbb
				//   SNE Vx,Vy   -> 9xy0
				if (line.split(",")[1].indexOf("V") < 0) {
				  // SNE Vx,byte -> 4xbb
				  vb = get_vx_comma_b ( line.slice(3) );
					mcwin.value += "4" + vb[0] + vb[1] + "\n";
				} else {
					// SNE Vx,Vy   -> 9xy0
				  vv = get_vx_comma_vy ( line.slice(3) );
					mcwin.value += "9" + vv[0] + vv[1] + "0" + "\n";
			  }
		  } else if (line.slice(0,3) == "LD ") {
				// LD (Load) can take the following forms:
				//   LD Vx,byte -> 6xbb
				//   LD Vx,Vy   -> 8xy0
				//   LD I,nnn   -> Annn
				//   LD Vx,DT   -> Fx07
				//   LD Vx,K    -> Fx0A
				//   LD DT,Vx   -> Fx15
				//   LD ST,Vx   -> Fx18
				//   LD F,Vx    -> Fx29
				//   LD B,Vx    -> Fx33
				//   LD [I],Vx  -> Fx55
				//   LD Vx,[I]  -> Fx65
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				// Handle the easy ones first
				if (pars[0] == "I") {
				  // LD I,nnn   -> Annn
					mcwin.value += "A" + pars[1].trim() + "\n";
				} else if (pars[0] == "DT") {
				  // LD DT,Vx   -> Fx15
					mcwin.value += "F" + pars[1].slice(1).trim() + "15\n";
				} else if (pars[0] == "ST") {
					// LD ST,Vx   -> Fx18
					mcwin.value += "F" + pars[1].slice(1).trim() + "18\n";
				} else if (pars[0] == "F") {
					// LD F,Vx    -> Fx29
					mcwin.value += "F" + pars[1].slice(1).trim() + "29\n";
				} else if (pars[0] == "B") {
					// LD B,Vx    -> Fx33
					mcwin.value += "F" + pars[1].slice(1).trim() + "33\n";
				} else if (pars[0] == "[I]") {
					// LD [I],Vx  -> Fx55
					mcwin.value += "F" + pars[1].slice(1).trim() + "55\n";
				} else if (pars[1] == "DT") {
				  // LD Vx,DT   -> Fx07
					mcwin.value += "F" + pars[0].slice(1).trim() + "07\n";
				} else if (pars[1] == "K") {
				  // LD Vx,K    -> Fx0A
				} else if (pars[1] == "[I]") {
					// LD Vx,[I]  -> Fx65
					mcwin.value += "F" + pars[0].slice(1).trim() + "65\n";
				} else {
				  if (line.split(",")[1].indexOf("V") < 0) {
						// LD Vx,byte -> 6xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  mcwin.value += "6" + vb[0] + vb[1] + "\n";
				  } else {
						// LD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
						mcwin.value += "8" + vv[0] + vv[1] + "0" + "\n";
					}
				}
		  } else if (line.slice(0,4) == "ADD ") {
				// ADD can take the following forms:
				//   ADD Vx,byte -> 7xbb
				//   ADD Vx,Vy   -> 8xy4
				//   ADD I,Vx    -> Fx1E
				pars = line.slice(3).trim().split(",");
				pars[0] = pars[0].trim();
				pars[1] = pars[1].trim();
				if (pars[0] == "I") {
				  // ADD I,Vx    -> Fx1E
					mcwin.value += "F" + pars[1].slice(1).trim() + "1E\n";
			  } else {
				  if (pars[1].indexOf("V") < 0) {
						// ADD Vx,byte -> 7xbb
						vb = get_vx_comma_b ( line.slice(3) );
					  mcwin.value += "7" + vb[0] + vb[1] + "\n";
				  } else {
				  	// ADD Vx,Vy   -> 8xy0
						vv = get_vx_comma_vy ( line.slice(3) );
					  mcwin.value += "8" + vv[0] + vv[1] + "4" + "\n";
					}
			  }
		  } else if (line.slice(0,3) == "OR ") {
				vv = get_vx_comma_vy ( line.slice(2).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "1" + "\n";
		  } else if (line.slice(0,4) == "AND ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "2" + "\n";
		  } else if (line.slice(0,4) == "XOR ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "3" + "\n";
		  } else if (line.slice(0,4) == "SUB ") {
				vv = get_vx_comma_vy ( line.slice(3).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "5" + "\n";
		  } else if (line.slice(0,4) == "SHR ") {
				if (line.indexOf(",") >= 0) {
				  // SHR Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHR Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  mcwin.value += "8" + vv[0] + vv[1] + "6" + "\n";
		  } else if (line.slice(0,5) == "SUBN ") {
				vv = get_vx_comma_vy ( line.slice(4).trim() );
			  mcwin.value += "8" + vv[0] + vv[1] + "7" + "\n";
		  } else if (line.slice(0,4) == "SHL ") {
				if (line.indexOf(",") >= 0) {
				  // SHL Vx,Vy
				  vv = get_vx_comma_vy ( line.slice(3).trim() );
				  if (vv[0].length <= 0) {
						vv[0] = "?";
				  }
				} else {
				  // SHL Vx
				  vv = [line.slice(3).trim()[1],"1"];
				}
			  mcwin.value += "8" + vv[0] + vv[1] + "E" + "\n";
		  } else if (line.slice(0,4) == "RND ") {
				vb = get_vx_comma_b ( line.slice(3) );
			  mcwin.value += "C" + vb[0] + vb[1] + "\n";
		  } else if (line.slice(0,4) == "DRW ") {
		  	pars = line.slice(3).split(",");
		  	pars[0] = pars[0].trim();
		  	pars[1] = pars[1].trim();
		  	pars[2] = pars[2].trim();
			  mcwin.value += "D" + pars[0][1] + pars[1][1] + pars[2][0] + "\n";
		  } else if (line.slice(0,4) == "SKP ") {
		  	vx = line.slice(3).trim();
			  mcwin.value += "E" + vx[1] + "9E" + "\n";
		  } else if (line.slice(0,5) == "SKNP ") {
		  	vx = line.slice(4).trim();
			  mcwin.value += "E" + vx[1] + "A1" + "\n";
		  } else {
				mcwin.value += "[??]" + line + "\n";
		  }
		}
  }
}

function disassemble() {
  // console.log ("Disassemble code");
  bintxt = document.getElementById ( "machine" ).value;
  // console.log ( "Text = " + bintxt );
  opts = document.getElementById ( "disassem_opts" ).value;
  console.log ( "Disassemble with options: " + opts );

  // Normalize line endings and remove empty lines
	text = replaceAll( bintxt, "\r", "\n");
	while (text.indexOf("\n\n") >= 0) {
		text = replaceAll(text, "\n\n", "\n");
	}
	// Convert to upper case
	text = "" + text.toUpperCase();
	// Remove all line endings
	while (text.indexOf("\n") >= 0) {
		text = replaceAll(text, "\n", "");
	}
	// Remove all spaces
	while (text.indexOf(" ") >= 0) {
		text = replaceAll(text, " ", "");
	}
	// Split by 4 digits per instruction
  lines = [];
  while (text.length > 0) {
		lines.push ( text.slice(0,4) );
		text = text.slice(4)
  }

  // Clear the source window
  document.getElementById ( "source" ).value = "";
	// Process the lines one by one
	for (l=0; l<lines.length; l++) {

		if (opts.indexOf("L") >= 0) {
		  // document.getElementById ( "source" ).value += "L"+((l*2)+0x200).toString(16).toUpperCase() + ": ";
		  document.getElementById ( "source" ).value += ((l*2)+0x200).toString(16).toUpperCase() + ": ";
		}
		if (opts.indexOf("H") >= 0) {
		  document.getElementById ( "source" ).value += lines[l] + "  ";
		}

		// #### : 00E0 00EE
	  if (lines[l] == "00E0") {
		  document.getElementById ( "source" ).value += "CLS" + "\n";
		} else if (lines[l] == "00EE") {
		  document.getElementById ( "source" ).value += "RET" + "\n";

		// #nnn : 0 1 2 A B
		} else if (lines[l][0] == "0") {
		  document.getElementById ( "source" ).value += "SYS " + lines[l].slice(1) + "\n";
		} else if (lines[l][0] == "1") {
		  // document.getElementById ( "source" ).value += "JP L" + lines[l].slice(1) + "\n";
		  document.getElementById ( "source" ).value += "JP " + lines[l].slice(1) + "\n";
		} else if (lines[l][0] == "2") {
		  // document.getElementById ( "source" ).value += "CALL L" + lines[l].slice(1) + "\n";
		  document.getElementById ( "source" ).value += "CALL " + lines[l].slice(1) + "\n";
		} else if (lines[l][0] == "A") {
		  document.getElementById ( "source" ).value += "LD I," + lines[l].slice(1) + "\n";
		} else if (lines[l][0] == "B") {
		  document.getElementById ( "source" ).value += "JP V0," + lines[l].slice(1) + "\n";

		// #nkk or #xkk : 3 4 6 7 C
		} else if (lines[l][0] == "3") {
		  document.getElementById ( "source" ).value += "SE V" + lines[l][1] + "," + lines[l].slice(2) + "\n";
		} else if (lines[l][0] == "4") {
		  document.getElementById ( "source" ).value += "SNE V" + lines[l][1] + "," + lines[l].slice(2) + "\n";
		} else if (lines[l][0] == "6") {
		  document.getElementById ( "source" ).value += "LD V" + lines[l][1] + "," + lines[l].slice(2) + "\n";
		} else if (lines[l][0] == "7") {
		  document.getElementById ( "source" ).value += "ADD V" + lines[l][1] + "," + lines[l].slice(2) + "\n";
		} else if (lines[l][0] == "C") {
		  document.getElementById ( "source" ).value += "RND V" + lines[l][1] + "," + lines[l].slice(2) + "\n";

		// #xy# : 5, 8, 9, D
		} else if (lines[l][0] == "5") {
		  if (lines[l][3] == "0") {
			  document.getElementById ( "source" ).value += "SE V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else {
			  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
			}
		} else if (lines[l][0] == "8") {
		  if (lines[l][3] == "0") {
			  document.getElementById ( "source" ).value += "LD V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "1") {
			  document.getElementById ( "source" ).value += "OR V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "2") {
			  document.getElementById ( "source" ).value += "AND V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "3") {
			  document.getElementById ( "source" ).value += "XOR V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "4") {
			  document.getElementById ( "source" ).value += "ADD V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "5") {
			  document.getElementById ( "source" ).value += "SUB V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "6") {
			  document.getElementById ( "source" ).value += "SHR V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "7") {
			  document.getElementById ( "source" ).value += "SUBN V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else if (lines[l][3] == "E") {
			  document.getElementById ( "source" ).value += "SHL V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else {
			  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
			}
		} else if (lines[l][0] == "9") {
		  if (lines[l][3] == "0") {
			  document.getElementById ( "source" ).value += "SNE V" + lines[l][1] + ",V" + lines[l][2] + "\n";
			} else {
			  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
			}
		} else if (lines[l][0] == "D") {
		  document.getElementById ( "source" ).value += "DRW V" + lines[l][1] + ",V" + lines[l][2] + "," + lines[l][3] + "\n";

		// #x## : E, F
		} else if (lines[l][0] == "E") {
		  if (lines[l].slice(2) == "9E") {
			  document.getElementById ( "source" ).value += "SKP V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "A1") {
			  document.getElementById ( "source" ).value += "SKNP V" + lines[l][1] + "\n";
			} else {
			  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
			}
		} else if (lines[l][0] == "F") {
		  if (lines[l].slice(2) == "07") {
			  document.getElementById ( "source" ).value += "LD V" + lines[l][1] + ",DT\n";
		  } else if (lines[l].slice(2) == "0A") {
			  document.getElementById ( "source" ).value += "LD V" + lines[l][1] + ",K\n";
		  } else if (lines[l].slice(2) == "15") {
			  document.getElementById ( "source" ).value += "LD DT,V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "18") {
			  document.getElementById ( "source" ).value += "LD ST,V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "1E") {
			  document.getElementById ( "source" ).value += "ADD I,V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "29") {
			  document.getElementById ( "source" ).value += "LD F,V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "33") {
			  document.getElementById ( "source" ).value += "LD B,V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "55") {
			  document.getElementById ( "source" ).value += "LD [I],V" + lines[l][1] + "\n";
		  } else if (lines[l].slice(2) == "65") {
			  document.getElementById ( "source" ).value += "LD V" + lines[l][1] + ",[I]\n";
			} else {
			  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
			}


		// Unknown
		} else {
		  document.getElementById ( "source" ).value += "DATA " + lines[l] + "\n";
		}
  }
}

</script>

<body bgcolor="lightblue" onload="onload()">
<center>

<span id="title"><b>CHIP-8 Assembler/Disassembler</b></span>
<p/>
<table width="100%" style="padding:10px; border-spacing:2px; border:4px solid black; background-color:#dddddd; text-align:left; font-family: Arial, Helvetica, sans-serif; font-size: 14px;" >
  <colgroup>
		<col>
		<col>
  </colgroup>
  <thead>
		<tr>
		  <th style="text-align:center; padding:10px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Source Code</th>
		  <th></th>
		  <th style="text-align:center; padding:10px; border-spacing:2px; border:2px solid black; background-color:#aaffff;">Machine Code</th>
		</tr>
  </thead>
	<tbody>
  	<tr>
		  <td valign="top">
				<center>
				<textarea id="source" rows="25" cols="36"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false">
LD I,21E
RND V2,01
SE V2,01
LD I,21A
DRW V0,V1,4
ADD V0,04
SE V0,40
JP 200
LD V0,00
ADD V1,04
SE V1,20
JP 200
JP 218
LD V0,V4
CALL 010
CALL 040
LD V0,V1
				</textarea>


<!-- Junk test code

L200: LD I,21E		 ; Top
L202: RND V2,01
L204: SE V2,01
L206: LD I,21A
L208: DRW V0,V1,4
L20A: ADD V0,04
L20C: SE V0,40
L20E: JP 200		  ; JP Top
L210: LD V0,00
L212: ADD V1,04
L214: SE V1,20
L216: JP 200		  ; JP Top
L218: JP 218		  ; JP Here (done)
L21A: Data 8040		; Data 8040
L21C: Data 2010		; Data 2010
L21E: DATA 2040		; DATA 2040
L220: DATA 8010		; DATA 8010

CLS
RET
SYS 123
JP 123
CALL 123
SE V5, fa
SNE V5, fa
SE V5, V6
LD V5, fa
ADD V5, fa
LD V5, V6
OR V5, V6
AND V5, V6
XOR V5, V6
ADD V5, V6
SUB V5, V6
SHR V5
SHR V5, V6
SUBN V5, V6
SHL V5
SHL V5, V6
SNE V5, V6
LD I, 123
JP V0, 123
RND V5, fa
DRW V5, V6, 5
SKP V5
SKNP V5
LD V5, DT
LD V5, K
LD DT, V5
LD ST, V5
ADD I, V5
LD F, V5
LD B, V5
LD [I], V5
LD V5, [I]
-->
				</center>
			</td>
			<td>
				<center>
				<select id="assem_opts" onchange="changed_format()">
				<option value="H" selected>Plain Hex</option>
				<!-- <option value="I">Intel Hex</option> -->
				</select>
				<input type="button" name="assem" value="==>" onclick="assemble();"></input>
				<p/>
				<input type="button" name="disassem" value="<==" onclick="disassemble();"></input>
				<select id="disassem_opts" onchange="changed_format()">
				<option value="S" selected>Src</option>
				<option value="LS">Lab+Src</option> -->
				<option value="HS">Hex+Src</option> -->
				<option value="LHS">Lab+Hex+Src</option> -->
				</select>
				<p/>
				<!--
				<select id="format_to" onchange="changed_format()">
				<option value="Hex" selected>Hex</option>
				</select> -->
				</center>
			</td>
		  <td valign="top">
				<center>
				<!-- Generate hex from binary ch8 file with: od -v -tx1 -An filename -->

				<!-- $ od -v -tx1 -An bin/chip8/games/Maze.ch8
							 a2 1e c2 01 32 01 a2 1a d0 14 70 04 30 40 12 00
							 60 00 71 04 31 20 12 00 12 18 80 40 20 10 20 40
							 80 10 -->
<!-- Running Maze by hand (adding changes to the left)
I:  21A 21E 21E 21A 21E 21A 21E 21E 0?
V0: 10 C 9 4 0?
V1: 0?
V2: 0 1 0 0 1 0?
VF: 0?
PC: 208 206 204 202 200 20C 20A 208 204 202 200 20C 20A 208 206 204 202 200 20C 20A 208 206 204 202 200 20C 20A 208 204 202 200
SP: 0?
21A: 80 = 10000000
21B: 40 = 01000000
21C: 20 = 00100000
21D: 10 = 00010000
21E: 20 = 00100000
21F: 40 = 01000000
220: 80 = 10000000
222: 10 = 00010000
0123456789ABCDEF0123456789ABCDEF0
001010001000001010000000
010001000100010001000000
100000100010100000100000
000100010001000100010000
-->

<!-- Maze code
200 a21e LD   I,21E
202 c201 RND  V2,01
204 3201 SE   V2,01
206 a21a LD   I,21A
208 d014 DRW  V0,V1,4
20A 7004 ADD  V0,04
20C 3040 SE   V0,40
20E 1200 JP   200
210 6000 LD   V0,00
212 7104 ADD  V1,04
214 3120 SE   V1,20
216 1200 JP   200
218 1218 JP   218
21A 8040  1000 0000 0100 0000
21C 2010  0010 0000 0001 0000
21E 2040  0010 0000 0100 0000
220 8010  1000 0000 0001 0000
-->

				<!-- $ od -v -tx1 -An bin/chip8/games/Tetris.ch8
							 a2 b4 23 e6 22 b6 70 01 d0 11 30 25 12 06 71 ff
							 d0 11 60 1a d0 11 60 25 31 00 12 0e c4 70 44 70
							 12 1c c3 03 60 1e 61 03 22 5c f5 15 d0 14 3f 01
							 12 3c d0 14 71 ff d0 14 23 40 12 1c e7 a1 22 72
							 e8 a1 22 84 e9 a1 22 96 e2 9e 12 50 66 00 f6 15
							 f6 07 36 00 12 3c d0 14 71 01 12 2a a2 c4 f4 1e
							 66 00 43 01 66 04 43 02 66 08 43 03 66 0c f6 1e
							 00 ee d0 14 70 ff 23 34 3f 01 00 ee d0 14 70 01
							 23 34 00 ee d0 14 70 01 23 34 3f 01 00 ee d0 14
							 70 ff 23 34 00 ee d0 14 73 01 43 04 63 00 22 5c
							 23 34 3f 01 00 ee d0 14 73 ff 43 ff 63 03 22 5c
							 23 34 00 ee 80 00 67 05 68 06 69 04 61 1f 65 10
							 62 07 00 ee 40 e0 00 00 40 c0 40 00 00 e0 40 00
							 40 60 40 00 40 40 60 00 20 e0 00 00 c0 40 40 00
							 00 e0 80 00 40 40 c0 00 00 e0 20 00 60 40 40 00
							 80 e0 00 00 40 c0 80 00 c0 60 00 00 40 c0 80 00
							 c0 60 00 00 80 c0 40 00 00 60 c0 00 80 c0 40 00
							 00 60 c0 00 c0 c0 00 00 c0 c0 00 00 c0 c0 00 00
							 c0 c0 00 00 40 40 40 40 00 f0 00 00 40 40 40 40
							 00 f0 00 00 d0 14 66 35 76 ff 36 00 13 38 00 ee
							 a2 b4 8c 10 3c 1e 7c 01 3c 1e 7c 01 3c 1e 7c 01
							 23 5e 4b 0a 23 72 91 c0 00 ee 71 01 13 50 60 1b
							 6b 00 d0 11 3f 00 7b 01 d0 11 70 01 30 25 13 62
							 00 ee 60 1b d0 11 70 01 30 25 13 74 8e 10 8d e0
							 7e ff 60 1b 6b 00 d0 e1 3f 00 13 90 d0 e1 13 94
							 d0 d1 7b 01 70 01 30 25 13 86 4b 00 13 a6 7d ff
							 7e ff 3d 01 13 82 23 c0 3f 01 23 c0 7a 01 23 c0
							 80 a0 6d 07 80 d2 40 04 75 fe 45 02 65 04 00 ee
							 a7 00 f2 55 a8 04 fa 33 f2 65 f0 29 6d 32 6e 00
							 dd e5 7d 05 f1 29 dd e5 7d 05 f2 29 dd e5 a7 00
							 f2 65 a2 b4 00 ee 6a 00 60 19 00 ee 37 23 -->

				<!-- $ od -v -tx1 -An bin/chip8/games/Guess.ch8
							 6e 01 00 e0 6d 01 6a 01 6b 01 8c d0 8c e2 4c 00
							 12 20 88 d0 22 3e 3a 40 12 20 6a 01 7b 06 3c 3f
							 7d 01 3d 3f 12 0a f0 0a 40 05 89 e4 8e e4 3e 40
							 12 02 6a 1c 6b 0d 88 90 00 e0 22 3e 12 3c a2 94
							 f8 33 f2 65 22 54 da b5 7a 04 81 20 22 54 da b5
							 7a 05 00 ee 83 10 83 34 83 34 83 14 a2 62 f3 1e
							 00 ee e0 a0 a0 a0 e0 40 40 40 40 40 e0 20 e0 80
							 e0 e0 20 e0 20 e0 a0 a0 e0 20 20 e0 80 e0 20 e0
							 e0 80 e0 a0 e0 e0 20 20 20 20 e0 a0 e0 a0 e0 e0
							 a0 e0 20 e0 -->

				<textarea id="machine" rows="25" cols="36"
				   autocomplete="off" autocorrect="off"
				   autocapitalize="off" spellcheck="false">
a21e
c201
3201
a21a
d014
7004
3040
1200
6000
7104
3120
1200
1218
8040
2010
2040
8010
				</textarea>
				</center>
			</td>
		</tr>
	</tbody>
</table>
<p/>
=== Assembler Syntax === <!-- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM -->
<table><tr><td>
<tt>
<pre>
0nnn - SYS addr           Jump to a machine code routine at nnn.
00E0 - CLS                Clear the display.
00EE - RET                Return from a subroutine.
1nnn - JP addr            Jump to location nnn.
2nnn - CALL addr          Call subroutine at nnn.
3xkk - SE Vx, byte        Skip If Equal Immediate: Skip next instruction if Vx = kk.
4xkk - SNE Vx, byte       Skip If Not Equal Immediate: Skip next instruction if Vx != kk.
5xy0 - SE Vx, Vy          Skip If Equal Register: Skip next instruction if Vx = Vy.
6xkk - LD Vx, byte        Load Immediate: Set Vx = kk.
7xkk - ADD Vx, byte       Add Immediate: Set Vx = Vx + kk.
8xy0 - LD Vx, Vy          Load Register: Set Vx = Vy.
8xy1 - OR Vx, Vy          Or Register: Set Vx = Vx OR Vy.
8xy2 - AND Vx, Vy         And Register: Set Vx = Vx AND Vy.
8xy3 - XOR Vx, Vy         XOR Register: Set Vx = Vx XOR Vy.
8xy4 - ADD Vx, Vy         Add Register: Set Vx = Vx + Vy, set VF = carry.
8xy5 - SUB Vx, Vy         Sub Register: Set Vx = Vx - Vy, set VF = NOT borrow.
8xy6 - SHR Vx {, Vy}      Shift Right: Set Vx = Vx SHR 1.
8xy7 - SUBN Vx, Vy        Sub Negative Register: Set Vx = Vy - Vx, set VF = NOT borrow.
8xyE - SHL Vx {, Vy}      Shift Left: Set Vx = Vx SHL 1.
9xy0 - SNE Vx, Vy         Skip If Not Equal: Skip next instruction if Vx != Vy.
Annn - LD I, addr         Load I Immediate: Set I = nnn.
Bnnn - JP V0, addr        Jump to V0 with offset nnn.
Cxkk - RND Vx, byte       Rand: Set Vx to a random number (0 to 255) AND byte value
Dxyn - DRW Vx, Vy, n      Draw: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision.
Ex9E - SKP Vx             Skip if Key[Vx]: Skip next instruction if key with the value of Vx is pressed.
ExA1 - SKNP Vx            Skip if !Key[Vx]: Skip next instruction if key with the value of Vx is not pressed.
Fx07 - LD Vx, DT          Load Vx from Delay Timer: Set Vx = delay timer value.
Fx0A - LD Vx, K           Load Vx from next Key: Wait for a key press, store the value of the key in Vx.
Fx15 - LD DT, Vx          Load Delay Timer from Vx: Set delay timer = Vx.
Fx18 - LD ST, Vx          Load Sound Timer from Vx: Set sound timer = Vx.
Fx1E - ADD I, Vx          Add Vx to I: Set I = I + Vx.
Fx29 - LD F, Vx           Load I from Sprite location: Set I = location of sprite for digit Vx.
Fx33 - LD B, Vx           Load BCD from X into Memory[I]: Store BCD representation of Vx in memory locations I, I+1, and I+2.
Fx55 - LD [I], Vx         Save Registers: Store registers V0 through Vx in memory starting at location I.
Fx65 - LD Vx, [I]         Restore Register: Read registers V0 through Vx from memory starting at location I.
</pre>
</tt>
</td></tr></table>

<!--

=== Alternate Syntax from: https://github.com/wernsey/chip8 ===

<table><tr><td>
<tt>
<pre>
 |--------------------|-------------------|----------------------------------------------------|
 | Chip8 Instruction  |  Mnemonic         | Description                                        |
 |--------------------|-------------------|----------------------------------------------------|
 |  0nnn              |   `sys nnn`       | System Call                                        |
 |  00E0              |   `cls`           | Clear Screen                                       |
 |  00EE              |   `ret`           | Return                                             |
 |  1nnn              |   `jp addr`       | Jump to `addr`                                     |
 |  2nnn              |   `call addr`     | Call routine at `addr`                             |
 |  3nkk              |   `se Vn kk`      | Skip if `Vn` equals `kk`                           |
 |  4nkk              |   `sne Vn kk`     | Skip if `Vn` does not equal `kk`                   |
 |  5xy0              |   `se Vx Vy`      | Skip if `Vn` equals `Vy`                           |
 |  6xkk              |   `ld Vx, kk`     | Loads a literal value `kk` into `Vx`               |
 |  7nkk              |   `add Vn, kk`    | Add `kk` to register `Vx`                          |
 |  8xy0              |   `ld Vx, Vy`     | Loads register `Vy` into `Vx`                      |
 |  8xy1              |   `or Vx, Vy`     | Bitwise OR the value in `Vy` with register `Vx`    |
 |  8xy2              |   `and Vx, Vy`    | Bitwise AND the value in `Vy` with register `Vx`   |
 |  8xy3              |   `xor Vx, Vy`    | Bitwise XOR the value in `Vy` with register `Vx`   |
 |  8xy4              |   `add Vx, Vy`    | Add the value in `Vy` to register `Vx`             |
 |  8xy5              |   `sub Vx, Vy`    | Subtract the value in `Vy` from register `Vx`      |
 |  8xy6              |   `shr Vx [, Vy]` | Shift `Vx` to the right with the value in `Vy`     |
 |  8xy7              |   `subn Vx, Vy`   | Subtract the value in `Vy` from `Vx`, no carry     |
 |  8xyE              |   `shl Vx [, Vy]` | Shift `Vx` to the left with the value in `Vy`      |
 |  9xy0              |   `sne Vx Vy`     | Skip if `Vn` does not equal `Vy`                   |
 |  Annn              |   `ld I, nnn`     | Loads `nnn` into register `I`                      |
 |  Bnnn              |   `jp v0, addr`   | Jump to `v0 + addr`                                |
 |  Cnkk              |   `rnd Vn, kk`    | random number AND `kk` into `Vn`                   |
 |  Dxyn              |   `drw Vx, Vy, n` | Draw a sprite of `n` rows at `Vx,Vy`               |
 |  En9E              |   `skp Vn`        | Skip if key in `Vn` pressed                        |
 |  EnA1              |   `sknp Vn`       | Skip if key in `Vn` not pressed                    |
 |  Fn0A              |   `ld Vn, K`      | loads a key pressed into `Vn`                      |
 |  Fn1E              |   `add I, Vn`     | Add the value in `Vn` to register `I`              |
 |  Fx07              |   `ld Vx, DT`     | Loads the delay timer into register `Vx`           |
 |  Fx15              |   `delay Vx`      | Loads register `Vx` into the delay timer           |
 |  Fx18              |   `sound Vx`      | Loads register `Vx` into the sound timer           |
 |  Fx29              |   `hex Vx`        | Loads the 8x5 font sprite of `Vx` into `I`         |
 |  Fx30[^super]      |   `hexx Vx`       | Loads the 8x10 font sprite of `Vx` into `I`        |
 |  Fx33              |   `bcd Vx`        | Load BCD value of `Vx` into `I` to `I+2`           |
 |  Fx55              |   `stor Vx`       | Stores `V0` through `Vx` to the address in `I`     |
 |  Fx65              |   `rstr Vx`       | Restores `V0` through `Vx` from the address in `I` |
 |  Fx75[^super]      |   `storx Vx`      | Stores `V0` through `Vx` to the reserved space     |
 |  Fx85[^super]      |   `rstrx Vx`      | Restores `V0` through `Vx` from the reserved space |
 |  00Cn[^super]      |   `scd n`         | Scroll down `n` pixels                             |
 |  00FB[^super]      |   `scr`           | Scroll right                                       |
 |  00FC[^super]      |   `scl`           | Scroll Left                                        |
 |  00FD[^super]      |   `exit`          | Exits the SuperChip48 interpreter                  |
 |  00FE[^super]      |   `low`           | Low res mode                                       |
 |  00FF[^super]      |   `high`          | Enable 128x64 high-res mode                        |
 |--------------------|-------------------|----------------------------------------------------|

 [^super]: Denotes a Super Chip48 instruction.
</pre>
</tt>
</td></tr></table>
-->

</center>

</body>

</center>

</html>

